<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git</title>
      <link href="/2022/02/17/git/"/>
      <url>/2022/02/17/git/</url>
      
        <content type="html"><![CDATA[<h1 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h1><div class="note info"><p>这一part主要关于git的使用和基本步骤。</p></div><h2 id="git不同情况的使用"><a href="#git不同情况的使用" class="headerlink" title="git不同情况的使用"></a>git不同情况的使用</h2><h3 class="bamboo-h " id="企业项目">企业项目</h3><br><p><strong>这个时候一般都是有代码和分支</strong></p><ul><li>1.拉取代码到本地 git clone</li><li>2.在本地新建个人分支并切换：git checkout -b dev //dev是分支名字</li><li>3.关联本地分支和远程分支<br><code>git branch --set-upstream-to=origin/本地分支对应的远程分支  你当前的本地分支</code></li><li>4.git pull 拉取最新代码</li><li>5.在该分支上进行代码的add和commit</li><li>6.git push origin 分支名字</li></ul><h3 class="bamboo-h " id="个人项目">个人项目</h3><br><h4 id="通过github新建项目"><a href="#通过github新建项目" class="headerlink" title="通过github新建项目"></a>通过github新建项目</h4><p>1.在github上新建仓库<br><img src="/2022/02/17/git/1.png" class="lazyload placeholder" data-srcset="/2022/02/17/git/1.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="新建仓库"><br>2.在本地 vscode 下载<br><code>git clone 仓库地址</code><br>3.编写代码<br>4.暂存<br><code>git add .</code><br>5.提交<br><code>git commit -m &#39;提交信息&#39;</code><br>6.关联本地分支和远程分支<br><code>git branch --set-upstream-to=origin/本地分支对应的远程分支  你当前的本地分支</code><br>7.推送代码<br><code>git push origin 分支</code></p><h4 id="通过本地新建项目"><a href="#通过本地新建项目" class="headerlink" title="通过本地新建项目"></a>通过本地新建项目</h4><p>需要自己初始化一个项目，多出.git目录，下面保存的是版本信息。<br><code>git init</code><br>后面的步骤如图上,但是要关联本地仓库和远程仓库<br><code>git remote add origin 仓库地址 //关联远程库</code></p><h4 id="把已有项目和github上关联"><a href="#把已有项目和github上关联" class="headerlink" title="把已有项目和github上关联"></a>把已有项目和github上关联</h4><p><strong>这个时候一般都是有代码和分支</strong><br>1.需要自己选择创建新分支还是到master分支上</p><ul><li>直接git push会报错,需要将本地分支关联到远程分支<br>  <strong>报错：更新被拒绝，因为远程仓库包含您本地尚不存在的提交。这通常是因为另外一个仓库已向该引用进行了推送。再次推送前，您可能需要先整合远程变更</strong></li></ul><p>2.提示远程仓库没有本地的代码，所以拉取代码</p><ul><li>git pull 拉取最新代码<br>  <strong>提示信息,当前分支没有跟踪信息,请指定您要合并哪一个分支</strong><br>因为在执行git pull, git push操作时不知道指定对应的哪个远程分支，你只要没有显示指定，git pull的时候，就会提示你。<br>解决方法:<br><code>git branch --set-upstream-to=origin/本地分支对应的远程分支  你当前的本地分支    </code>    </li></ul><h2 id="常见的git命令使用"><a href="#常见的git命令使用" class="headerlink" title="常见的git命令使用"></a>常见的git命令使用</h2><p><code>git config  —list //显示git配置</code><br><code>git remote -v  //查看远程仓库详细信息</code><br><code>git status //查看仓库状况</code><br><code>git branch -r //列出所有远程分支</code><br><code>git branch -a //列出所有本地分支和远程分支</code><br><code>git reset 版本号 //回退版本</code><br><code>git checkout -b dev //创建并切换到dev分支</code><br><code>git merge dev //把dev分支合并到当前分支上</code></p><ul><li>git pull和git fetch的区别<ul><li><code>git fetch  //是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</code></li><li><code>git pull  //则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</code></li></ul></li></ul><p><code>git branch --unset-upstream //撤销本地分支与远程分支的映射关系</code><br><code>git branch -vv //查看本地分支和远程分支的映射关系</code><br><code>git log —oneline —graph //查看git 分支 tree</code><br><code>git checkout . //恢复暂存区的所有文件到工作区</code></p><p><code>git rebase //分支劈叉</code> <a href="https://www.jianshu.com/p/f7ed3dd0d2d8">解释1</a>  <a href="https://www.bilibili.com/video/av51229455?zw">解释2</a></p><h3 class="bamboo-h " id="commit格式">commit格式</h3><br><p><img src="/2022/02/17/git/feat.png" class="lazyload placeholder" data-srcset="/2022/02/17/git/feat.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="commit"></p>]]></content>
      
      
      <categories>
          
          <category> git的使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code standard</title>
      <link href="/2022/02/17/code-standard/"/>
      <url>/2022/02/17/code-standard/</url>
      
        <content type="html"><![CDATA[<h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><div class="note info"><p>这一part主要讲的是平常代码的规范及其配置，包括eslint，stylelint和prettier。</p></div><h2 class="bamboo-h " id="eslint">eslint</h2><br> <p><strong>1.下载eslint（vscode 插件）</strong><br><code>npm install eslint --save-dev</code></p><p><strong>2.基本配置</strong><br>root: true<br>env：环境<br>extends：扩展包,会包括一些写好的规则<br>parserOptions: 可解析的选项</p><pre class="line-numbers language-none"><code class="language-none">extends: [&quot;plugin:vue&#x2F;essential&quot;, &quot;eslint:recommended&quot;,&#39;@vue&#x2F;airbnb&#39;],parserOptions: &#123;parser: &quot;babel-eslint&quot;,&#125;, &#x2F;&#x2F;支持 es5 之外的语法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>rules:校验规则</p><p><strong>3.rules 的选项</strong><br>‘xxx 规则’：三种选项</p><ul><li>“off” or 0 - 关</li><li>“warn” or 1 - 警告 </li><li>“error” or 2 - 错误</li></ul><p><strong>4.常见的 rules</strong><br>4.1 句末分号<br>semi:该规则有两个选项，一个字符串选项和一个对象选项。<br><strong>字符串选项</strong>：</p><ul><li>“always”（默认）在语句末尾需要分号</li><li>“never”不允许使用分号作为语句的结尾（除了消除以[、(、/、+或开头的语句的歧义-）</li></ul><p><strong>对象选项</strong>（当”always”）：</p><ul><li>“omitLastInOneLineBlock”: true 忽略块中的最后一个分号，其中它的大括号（以及块的内容）在同一行中</li></ul><p><strong>对象选项</strong>（当”never”）：</p><ul><li>“beforeStatementContinuationChars”: “any”[（默认）如果下一行以、(、/、+或开头，则忽略语句末尾的分号（或缺少分号）-。</li><li>“beforeStatementContinuationChars”: “always”[如果下一行以、(、/、+或开头，则在语句末尾需要分号-。</li><li>“beforeStatementContinuationChars”: “never”如果即使下一行以[, (, /,+或开头也不会造成 ASI 危险，则不允许使用分号作为语句的结尾-。<br><code>semi:[&#39;error&#39;,&#39;never&#39;]</code></li></ul><h2 class="bamboo-h " id="stylelint">stylelint</h2><br> <h3 id="1-下载相关"><a href="#1-下载相关" class="headerlink" title="1.下载相关"></a>1.下载相关</h3><p>1.1下载 stylelint</p><p><code>npm install stylelint --save-dev</code><br><code>custom-property-no-missing-var-function //如果不是最新版本会报错</code></p><p>1.2下载配置规则</p><p>官方提供两套标准<br><code>stylelint-config-recommended //包含可能报错的rule，code format的css标准</code><br><code>stylelint-config-standard //继承于recommend，一些常见的css书写标准</code><br><code>stylelint-config-standard-scss //解析scss的包,普通的stylelint只能解析css文件</code><br><code>stylelint-config-recommended-vue //解析vue的包,如果不下载这个包会报错</code><br><strong>unknown word:CssSyntaxError</strong> 识别不了vue文件<br>1.3下载 “stylelint-order”: “^5.0.0”  配置规则 尝试校验</p><h3 id="2-以scss文件为例-gt-校验scss文件"><a href="#2-以scss文件为例-gt-校验scss文件" class="headerlink" title="2.以scss文件为例====&gt;校验scss文件"></a>2.以scss文件为例====&gt;校验scss文件</h3><p>下载安装：<br>“sass”: “^1.49.7”,<br>“sass-loader”: “^7.3.1”,</p><h3 id="3-在package-json-gt-编写配置文件"><a href="#3-在package-json-gt-编写配置文件" class="headerlink" title="3.在package.json====&gt;编写配置文件"></a>3.在package.json====&gt;编写配置文件</h3><p><code>&quot;lint:style&quot;: &quot;stylelint \&quot;src/**/*.(css|scss|vue)\&quot; --fix&quot;</code><br>匹配src文件夹下的css/scss/vue文件</p><ul><li>如果出现TypeError: Class extends value undefined is not a constructor or null #5</li><li><em>解决：</em>*<br><code>npm install —save-dev postcss@8</code><br>附上<a href="https://github.com/stylelint-scss/stylelint-config-standard-scss/issues/5">原帖地址</a></li></ul><p><strong>弃用,下面的方法已弃用</strong></p><h3 id="4-下载stylelint插件，保存的时候自动修复。-插件有问题弃用"><a href="#4-下载stylelint插件，保存的时候自动修复。-插件有问题弃用" class="headerlink" title="4.下载stylelint插件，保存的时候自动修复。(插件有问题弃用)"></a>4.下载stylelint插件，保存的时候自动修复。(插件有问题弃用)</h3><p>配置：setting.json</p><pre class="line-numbers language-none"><code class="language-none">&quot;editor.codeActionsOnSave&quot;: &#123;       &quot;source.fixAll&quot;: true,   &#125;, &quot;stylelint.validate&quot;: [       &quot;css&quot;,       &quot;less&quot;,       &quot;postcss&quot;,       &quot;scss&quot;,       &quot;vue&quot;,       &quot;sass&quot;   ],<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-忽略文件-gt-stylelintignore-js"><a href="#5-忽略文件-gt-stylelintignore-js" class="headerlink" title="5.忽略文件====&gt;stylelintignore.js"></a>5.忽略文件====&gt;stylelintignore.js</h3><ul><li>dist</li><li>node_modules</li><li>package.json<br>ps：eslint也可以配置忽略文件。</li></ul><div class="note warning"><p>如何在在commit之前触发校验规则？使用预提交！</p></div><h2 class="bamboo-h " id="预提交">预提交</h2><br><p><strong>通过git hook+husky+lint-staged来实现</strong><br>1.下载husky<br><code>npm i husky -D --registry=https://registry.npm.taobao.org</code><br>2.配置package.json</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;在script下面一行配置&quot;husky&quot;: &#123;  &quot;hooks&quot;: &#123;    &quot;pre-commit&quot;: &quot;echo \&quot;git commit trigger husky pre-commit hook\&quot; &quot;  &#125;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>pre-commit</strong>：可以在commit之前执行echo &quot;git commit trigger husky pre-commit hook&quot;<br>3.下载lint-staged<br><code>npm i lint-staged prettier -D --registry=https://registry.npm.taobao.org</code><br>4.配置lint-staged,在package.json中配置</p><pre class="line-numbers language-none"><code class="language-none">&quot;lint-staged&quot;: &#123;    &quot;src&#x2F;**&#x2F;*.&#123;js,vue&#125;&quot;: [      &quot;prettier --write&quot;,      &quot;eslint --cache --fix&quot;    ],    &quot;src&#x2F;**&#x2F;*.&#123;vue,scss&#125;&quot;: [      &quot;stylelint --fix&quot;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span class="pbg yellow">最终模版</span><pre class="line-numbers language-none"><code class="language-none">&quot;husky&quot;: &#123;    &quot;hooks&quot;: &#123;      &quot;pre-commit&quot;: &quot;echo &#39;git commit trigger husky pre-commit hook&#39; &amp;&amp; lint-staged&quot;    &#125;&#125;,&quot;lint-staged&quot;: &#123;&quot;src&#x2F;**&#x2F;*.&#123;js,vue&#125;&quot;: [&quot;prettier --write&quot;,&quot;eslint --cache --fix&quot;,],&quot;src&#x2F;**&#x2F;*.&#123;vue,scss&#125;&quot;: [      &quot;stylelint --fix&quot;  ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本文参考链接:<br><a href="https://www.jianshu.com/p/5d7e0e744a56">链接1</a><br><a href="https://neveryu.github.io/2020/06/10/husky-lint-staged/">链接2</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 代码规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/2022/02/13/vue/"/>
      <url>/2022/02/13/vue/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这一part主要涉及到vue的基本面试问题</p></div><h2 class="bamboo-h " id="render和template">render和template</h2><br><p><strong>render和template的区别</strong></p><ul><li>Render是一种编译方式，render中有一个函数h，这个h是createElement方法，会把单文件组件进行虚拟dom的创建，然后通过render进行解析</li><li>Template也是一种编译方法，但是template最终还是会通过render的方式进行编译，render的性能比template性能好，且render的函数优先级大于template render会先执行。<u>在vue源码中，template会被转化成render函数。</u> </li></ul><h2 class="bamboo-h " id="v-if/v-show">v-if/v-show</h2><br><ul><li><strong>v-if和v-show</strong><ul><li>v-if 通过控制dom节点存在控制元素的显隐  v-show通过设置dom的display样式</li><li>v-if 是真正的条件渲染 切换的时候有一个局部编译和卸载的过程，会销毁和重建内部的事件监听和子组件 v-show只是简单的css切换</li><li>v-if是惰性的 如果初始条件为假 就什么也不做 如果条件为真才会进行局部编译 编译被缓存之后 切换的时候会局部卸载 v-show不管怎么样都会被编译 然后被缓存 保留dom元素</li><li>v-if支持template语法 v-show不支持template语法</li><li>如果频繁切换用v-show v-if有更高的切换消耗 v-show有更高的初始渲染消耗</li></ul></li><li><strong>v-if和v-for</strong><ul><li>v-if和v-for不推荐一起使用，因为v-for的优先级比v-if高，v-if会重复运行到每个v-for循环中，对每个列表进行条件渲染，可以部分渲染节点，但是不适合跳过循环的执行。</li><li>*解决办法**：可以把v-if添加到父级元素上或者通过计算属性过滤掉不需要的某一项。</li></ul></li></ul><h2 class="bamboo-h " id="computed">computed</h2><br><span class="pbg yellow">Computed</span>是计算属性， 计算一个新属性并将该属性挂在到实例上， 要引用的地方像data一样引用就行。可以不在data里声明，直接在template中绑定，默认挂载在data里。<p><strong>注意事项</strong></p><ul><li>支持缓存 当属性内数据发生变化才会重新计算 性能开销比较小</li><li>不支持异步操作</li><li>基于data或者父组件prop中通过计算得到的属性</li><li>结果必须return出来</li><li>初始化就可以被检测到并且进行计算</li><li>默认走get方法 数据变化时调动set方法</li></ul><p><strong>使用场景</strong> :一个属性依赖于其他属性用computed，负责简单的逻辑。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;eg &lt;script&gt;export default&#123;computed:&#123;    formData()&#123;    get()&#123;      return this.value      &#125;      set(obj)&#123;      this.value&#x3D;obj      &#125;    &#125;,    getChange()&#123;    return xxx    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="watch">watch</h2><br><span class="pbg yellow">Watch</span>是监听属性，监听数据的新旧变化。<p><strong>注意事项</strong>c</p><ul><li>不支持缓存，数据发生变化就会直接发生变化</li><li>支持异步操作</li><li>函数接受两个参数 一个new一个old</li><li>监听的属性必须是data里声明的或者父组件传递的数据</li></ul><p><strong>使用场景</strong>： 一条数据会影响到多条数据的时候 需要异步操作的时候 负责复杂逻辑的时候<br>Watch还有很多属性默认使用的handler函数</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;eg &lt;script&gt;export default&#123;watch:&#123;   name:&#123;    handler(newName, oldName) &#123;      this.fullName &#x3D; newName + &#39; &#39; + this.lastName;    &#125;,      immediate: true,      &#x2F;&#x2F;      deep:true    &#125;    &#x2F;&#x2F;或者    &#39;name.firstName&#39;:&#123;    handler(newName, oldName) &#123;      this.fullName &#x3D; newName + &#39; &#39; + this.lastName;    &#125;,      immediate: true,      &#x2F;&#x2F;      deep:true  &#125;  &#125;&#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>immediate属性： 由于watch一开始绑定的时候不会执行，只有数据发生变化的时候才会执行 如果想要在绑定的时候就执行 可以设置这个属性 默认false，比如当父组件给子组件动态传值的时候子组件props首次获取父组件传来的默认值也需要执行监听函数的时候，组件创建时立即执行。</li><li>deep属性：<span class="pbg yellow">深度监听</span>。当对对象进行数据监听的时候，并不会监听到对象内部属性的变化，属性变化不会触发对象的监听函数，但是设置deep的时候监听起会层层往下遍历给对象的所有属性都加上监视器，导致性能开销很大可以通过对对象的某个属性设置监听。</li></ul><h2 class="bamboo-h " id="Vue 插槽">Vue 插槽</h2><br><p>什么是插槽？</p><ul><li>插槽就是用slot包裹的标签。  <slot></slot></li></ul><p>什么时候用插槽？</p><ul><li>开发中，需要把相同的公共标签抽出来封装成公共组件，然后在不同的模块引入，但是有时候，每个模块的需求不同，对组件样式的需求也不一样，可能需要我们在组件内部进行改写，但是如果组件内部被改写，那么引入该组件的模块都会被改写，如果我们只想改写单独模块内的组件，可以使用“插槽”。</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;eg&lt;button type&#x3D;&quot;submit&quot;&gt;  确认&lt;&#x2F;button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>默认插槽</strong><ul><li>当我们想要组件内部大部分都渲染确认，单独组件渲染其他文本的时候，我们可以使用默认插槽。不提供插槽内容就默认渲染原来的内容，提供插槽内容就渲染提供的数据。</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none"> &lt;!-- 公共组件 submit-button --&gt;&lt;button type&#x3D;&quot;submit&quot;&gt;  &lt;slot&gt;submit&lt;&#x2F;slot&gt;&lt;&#x2F;button&gt; &lt;!-- 单独模块 --&gt;&lt;submit-button&gt;&lt;&#x2F;submit-button&gt; 这个时候会默认渲染submit&lt;submit-button&gt;save&lt;&#x2F;submit-button&gt; 提供内容就会渲染成save1. &lt;!-- 插槽可以插入什么 --&gt;&lt;button type&#x3D;&quot;submit&quot;&gt;  &lt;slot&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;button&gt;  如果插槽内什么都不写就会直接渲染单独模块加的内容 &lt;!-- 单独模块 --&gt;&lt;submit-button&gt;hello world&lt;&#x2F;submit-button&gt; 直接渲染hello world的按钮2. &lt;!-- 插槽可以添加html模版代码 可以添加其他组件 公共组件插槽可以获取到单独模块的内容 --&gt;&lt;submit-button&gt;  &lt;span&gt;我是span标签&lt;&#x2F;span&gt;  你好&lt;&#x2F;submit-button&gt;&lt;submit-button&gt;  &lt;table&gt;&lt;&#x2F;table&gt; 引入table组件  你好&lt;&#x2F;submit-button&gt;&lt;submit-button&gt;  你好 &#123;&#123;data&#125;&#125;&lt;&#x2F;submit-button&gt;  可以渲染模版内的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果公共组件内部没有写slot，那么在模块内改写组件内部内容会被直接抛弃</li><li>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</li><li>具名插槽<ul><li>我们有时候会在一个组件内使用多个插槽，为了渲染不同的插槽效果，可以给他们命名，通过name。</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;!--公共组件 --&gt;&lt;template lang&#x3D;&quot;pug&quot;&gt;    .wrap        button             slot 保存        .header            slot(name&#x3D;&#39;header&#39;)        .main            slot(name&#x3D;&#39;main&#39;)        .footer            slot(name&#x3D;&#39;footer&#39;)&lt;&#x2F;template&gt;&lt;!--单独模块 --&gt;&lt;template lang&#x3D;&quot;pug&quot;&gt;  &lt;!--如果没有写会默认写入没有name的插槽里 --&gt;        submit-button 确认              template(v-slot:header) 这是页头            template(v-slot:main) 这是内容            template(v-slot:footer) 这是页脚&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>v-slot只能添加在template上，具名插槽可以使用缩写，用#来代替</strong></p><ul><li>作用域插槽<ul><li>单独模块需要访问公共模块里的数据，但是每个模版的内容都只在自己的作用域里编译，这歌时候我们一样让数据作为slot的一个属性进行绑定。</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;!--单独模块 --&gt;&lt;template lang&#x3D;&quot;pug&quot;&gt;    .wrap        .header            slot(name&#x3D;&#39;header&#39;)        .main            slot(name&#x3D;&#39;main&#39;)        .footer            slot(name&#x3D;&#39;footer&#39;)        .content(:content&#x3D;&#39;content&#39; name&#x3D;&#39;div&#39;) &#123;&#123;content&#125;&#125;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;    data()&#123;    return&#123;        data:&#123;          content:&#39;这是公共组件的内容&#39;,          title:&#39;这是公共组件的标题&#39;        &#125;            &#125;    &#125;  &#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>想要拿到单独模块里的数据 需要绑定到v-bind:content=’content’</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;!--公共组件 --&gt;&lt;template lang&#x3D;&quot;pug&quot;&gt; template(v-slot:default&#x3D;&#39;slotProps&#39;) &#123;&#123;slotProps.content&#125;&#125;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在template定义需要拿到哪个插槽的数据，通过v-slot:name=’slotProps’进行定义(v-slot=”slotProps”) 数据都放在slotProps里</p><p>当然也有简单写法：解构赋值</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--公共组件 --&gt;&lt;template lang&#x3D;&quot;pug&quot;&gt; template(v-slot:div&#x3D;&#39;&#123;data&#125;&#39;) &#123;&#123;data.title&#125;&#125; &#123;&#123;data.content&#125;&#125;&lt;&#x2F;template&gt;or更简写&lt;!--公共组件 --&gt;&lt;template lang&#x3D;&quot;pug&quot;&gt; template(#div&#x3D;&#39;&#123;data&#125;&#39;) &#123;&#123;data.title&#125;&#125; &#123;&#123;data.content&#125;&#125;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是不能template(#=’{data}’)   ，因为#的后面必须要求参数</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6-es12</title>
      <link href="/2022/02/13/es6-es12/"/>
      <url>/2022/02/13/es6-es12/</url>
      
        <content type="html"><![CDATA[<h1 id="es6到es12的回顾"><a href="#es6到es12的回顾" class="headerlink" title="es6到es12的回顾"></a>es6到es12的回顾</h1><div class="note info"><p>这一part主要回顾一下ECMA规范中从es6到es12的变化，包括一些比较常用的方法和api。</p></div><h2 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h2><h3 class="bamboo-h " id="字面量增强">字面量增强</h3><br><ul><li>当key和value相同的时候，可以进行简写</li><li>方法的简写</li><li>属性名的计算<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;1.当key和value相同的时候，可以进行简写var name&#x3D;&#39;123&#39;var age&#x3D;12var obj&#x3D;&#123;name,  age&#125;var obj1&#x3D;&#123;  &#x2F;&#x2F;2.方法的简写foo()&#123;&#125;,  &#x2F;&#x2F;3.计算属性名  [name+&#39;123&#39;]:&#39;牛啊牛啊&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 class="bamboo-h " id="解构">解构</h3><br><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><pre class="line-numbers language-none"><code class="language-none">var obj&#x3D;&#123;name:&#39;hhx&#39;,    age:18&#125;&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;var &#123;name,age&#125;&#x3D;obj &#x2F;&#x2F;和数组不同，没有顺序的限制，通过key来查找var &#123;name:newName&#125;&#x3D;obj &#x2F;&#x2F;把原来的name的value赋值给新的newName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><pre class="line-numbers language-none"><code class="language-none">var arr&#x3D;[&#39;abc&#39;,&#39;bca&#39;,&#39;cab&#39;]&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&gt;var [item1,item2,item3]&#x3D;namesvar [,itema,itemb]&#x3D;names &#x2F;&#x2F;只解构后面两个元素var [item,...newItem]&#x3D;names &#x2F;&#x2F;剩余参数，获取第一个数组和后面的新数组var [itema,itemb,itemc,itemd&#x3D;&#39;bbb&#39;]&#x3D;names &#x2F;&#x2F;解构的默认值，itemd在names中不存在，默认为‘bbb’<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="let和const">let和const</h3><br><ul><li>let和const定义的变量<span class="pbg yellow">不能重复定义</span>。</li><li>let和const<span class="pbg yellow">没有作用域提升</span>，但是let和const的变量在执行上下文创建阶段已经被创建不能被访问，除非被绑定求值。</li><li>var定义全局的时候会定义在<span class="pbg yellow">window</span>里，let和const不会，let和const会被定义在<span class="pbg yellow">variable map</span>里。</li><li>es5没有块级作用域，只有全局作用域和函数作用域。块级作用域对var无效，对let/const/function/class有效。但是不同的浏览器有不同的实现，有些浏览器会让function没有块级作用域。**{} / if / switch / for都有块级作用域**。<ul><li>全局作用域: 定义在全局的变量的集合。</li><li>函数作用域: 定义在函数内部的变量的集合。</li><li>块级作用域: es6新声明的，被{}包裹的代码块。<strong>let和const定义的变量会被限制在块级作用域内</strong>。</li><li>暂时性死区: 在let和const声明变量之前不能访问变量</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;eg : 比较常见的面试题const btn&#x3D;document.getElementTagNames(&#39;button&#39;)for(var i&#x3D;0;i&lt;btn.length;i++)&#123;btns[i].onclick&#x3D;function()&#123;  console.log(i)  &#125;&#125;&#x2F;&#x2F;这个时候打印的i访问的全局作用域，i已经变成最终的数字了&#x2F;&#x2F;改良版1.0const btn&#x3D;document.getElementTagNames(&#39;button&#39;)for(var i&#x3D;0;i&lt;5;i++)&#123;  (function(n)&#123;  console.log(n)  &#125;)(i)&#125;&#x2F;&#x2F;打印的时候会找上级作用域就是立即执行函数，立即执行函数把i值穿进去for(let i&#x3D;0;i&lt;btn.length;i++)&#123;btns[i].onclick&#x3D;function()&#123;  console.log(i)  &#125;&#125;&#x2F;&#x2F;访问的i是块级作用域中的i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="for of和for of">for of和for of</h3><br><p> <strong>for in: 循环只遍历可枚举属性，一般用来遍历对象</strong></p><pre class="line-numbers language-none"><code class="language-none">var obj &#x3D; &#123;a:1, b:2, c:3&#125;;    for (let key in obj) &#123;  console.log(key);&#125;&#x2F;&#x2F; a&#x2F;&#x2F; b&#x2F;&#x2F; c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>for of: 遍历可迭代对象，一般用来遍历数组</strong></p><pre class="line-numbers language-none"><code class="language-none">var arr &#x3D; [4,5,6];for (let key of arr) &#123;  console.log(key);&#125;&#x2F;&#x2F; 4&#x2F;&#x2F; 5&#x2F;&#x2F; 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="字符串模版">字符串模版</h3><br><ul><li>拼接字符串<code>$&#123;&#125;</code></li><li>在${}中可以进行简单计算，$(age*2)或者在$(change())调用函数</li><li>标签模版字符串：调用函数的方式<pre class="line-numbers language-none"><code class="language-none">function foo(m,n)&#123;console.log(m,n)&#125;const name&#x3D;&#39;hhx&#39;foo&#96;hello$&#123;name&#125;world&#96;&#x2F;&#x2F;[&#39;hello&#39;,&#39;world&#39;]  hhx  &#x2F;&#x2F;第一个参数是模块字符串完整的字符串被切成多块放到数组中&#x2F;&#x2F;第二个参数事模版字符串中 第一个$&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 class="bamboo-h " id="参数默认值">参数默认值</h3><br><pre class="line-numbers language-none"><code class="language-none">function foo(m,n)&#123;&#x2F;&#x2F;如果没有参数m，n，默认是undefined  &#x2F;&#x2F;如果需要默认值 直接让m&#x3D;‘’ n&#x3D;‘’&#125;function foo(m&#x3D;&#39;&#39;,n&#x3D;&#39;&#39;)&#123;&#x2F;&#x2F;如果没有参数m，n，默认是undefined  &#x2F;&#x2F;如果需要默认值 直接让m&#x3D;‘’ n&#x3D;‘’&#125;function foo(&#123;name&#x3D;&#39;hhx&#39;,age&#x3D;12&#125;&#x3D;&#123;&#125;)&#123;&#x2F;&#x2F;解构赋值默认参数&#125;&#x2F;&#x2F;函数的length就是参数的长度，默认值最后放在参数的后面，因为默认值以及后面的参数都不计算在lenght之内<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="函数的剩余参数">函数的剩余参数</h3><br><p>…params:将剩余的参数放到参数中，放到一个数组里面。</p><h3 class="bamboo-h " id="箭头函数的补充">箭头函数的补充</h3><br><p>1.没有显示原型<br>2.没有arguments<br>3.没有this，会去上层作用域里找</p><h3 class="bamboo-h " id="展开语法">展开语法</h3><br><p>函数调用，数组构造的时候，字面量对象构造的时候</p><pre class="line-numbers language-none"><code class="language-none">const names&#x3D;[&#39;abc&#39;,&#39;cba&#39;,&#39;bac&#39;]const name&#x3D;[&#39;why&#39;]&#x2F;&#x2F;函数调用时function foo(x,y,z)&#123;console.log(x,y,z)&#125;&#x2F;&#x2F;1.foo.apply(null,name)&#x2F;&#x2F;2.foo(...names) 把names一个一个对应穿进去&#x2F;&#x2F;3.foo(...name） 把字符串一个一个切开 w h y&#x2F;&#x2F;构造数组时const newNames&#x3D;[...names,...name]&#x2F;&#x2F;&#39;abc&#39;,&#39;cba&#39;,&#39;bac&#39;,&#39;w&#39;,&#39;h&#39;,&#39;y&#39;&#x2F;&#x2F;构造字面量对象的时候const obj&#x3D;&#123;name:&#39;123&#39;,age:12&#125;const info&#x3D;&#123;...obj,address:&#39;555&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span class="pbg yellow">ps：展开运算符其实进行的是浅拷贝</span>   <h3 class="bamboo-h " id="symbol的基本使用">symbol的基本使用</h3><br><p>对象的属性名都是字符串，很可能重复造成属性名的冲突，比如添加新的属性和值的时候不知道内部情况，可能会覆盖掉内部的属性。<br>利用symbol可以生成一个独一无二的值，symbol函数每次创建出来的值都是独一无二的。</p><pre class="line-numbers language-none"><code class="language-none">const s1&#x3D;Symbol(&#39;描述符&#39;)const s2&#x3D;Symbol()&#x2F;&#x2F;s1不等于s2&#x2F;&#x2F;symbol值作为keyconst obj&#x3D;&#123;[s1]:&#39;abc&#39;,    [s2]:&#39;cba&#39;&#125;&#x2F;&#x2F;1.新增属性obj[s3]&#x3D;&#39;bac&#39;&#x2F;&#x2F;也可以用obj.defineProperty&#x2F;&#x2F;2.获取属性值console.log(obj[s1],obj[s2])&#x2F;&#x2F;3.使用symbol作为key的属性名，不能用遍历&#x2F;obj.keys来获取symbol值,可以用getOwnPropertySymbolsconsole.log(Object.getOwnPropertySymbols(obj))&#x2F;&#x2F;4.用symbol.for(key)的方式创造出来的是相等的const sa&#x3D;Symbol.for(&#39;aaa&#39;)const sb&#x3D;Symbol.for(&#39;aaa&#39;)console.log(sa&#x3D;&#x3D;&#x3D;sb)&#x2F;&#x2F;5.用symbol.for(key)的方式创造出来的key是相等的const key&#x3D;Symbol.keyFor(sa)const sc&#x3D;Symbol.for(key)console.log(sa&#x3D;&#x3D;&#x3D;sc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="set: 新增的数据类型">set: 新增的数据类型</h3><br><p>常见的属性：</p><ul><li>size 长度</li><li>add(元素)</li><li>delete(元素)</li><li>has(元素)</li><li>clear() :把set清0</li><li>遍历：forEach 和for of<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;1.创建set结构const set &#x3D; new Set()set.add(10)set.add(20)&#x2F;&#x2F;2.添加set&#123;10,20&#125;set.add(&#123;&#125;)set.add(&#123;&#125;)const obj&#x3D;&#123;&#125;set.add(obj)set.add(obj)&#x2F;&#x2F;3.上面两个是不同的对象，保存不同的地址,下面两个增加的是同一个对象，指向同一个地址&#x2F;&#x2F;4.数组去重，支持展开运算符const arr&#x3D;[33,10,26,30,33,26]const arrSet&#x3D;new Set(arr)const newArr&#x3D;[...arrSet]console.log(newArr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 class="bamboo-h " id="weakset：新增的数据类型">weakset：新增的数据类型</h3><br><ul><li>内部不能重复，只能存放对象类型。</li><li>弱引用，如果没有其他引用对某个对象进行引用的话，那么gc可以对该对象进行回<pre class="line-numbers language-none"><code class="language-none">const weakSet&#x3D;new WeakSet()&#x2F;&#x2F;强引用：set&#x2F;&#x2F;弱引用：weakSetlet obj&#x3D;&#123;name:&#39;why&#39;&#125;weakSet.add(obj)weakSet.delete(obj)weakSet.has(obj)&#x2F;&#x2F;weakSet不能遍历，存储到weaSet的对象是没办法获取的&#x2F;&#x2F;weakSet的运用场景const personSet&#x3D;new WeakSet()class Person&#123;construtor()&#123;  personSet.add(this)  &#125;  running()&#123;    if(!personSet.has(this))&#123;    throw new Error(&#39;不能通过非构造方法创建的对象调用running方法&#39;)    &#125;      console.log(&#39;running&#39;,this)   &#125;&#125;const p&#x3D;new Person()p.running()p.running.call(&#123;name:&#39;why&#39;&#125;)&#x2F;&#x2F;running Person&#123;&#125;&#x2F;&#x2F;running &#123;name:&#39;why&#39;&#125;&#x2F;&#x2F;如果不希望通过call或者其他方法来进行调用，可以用weakSet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 class="bamboo-h " id="map：存储键值对">map：存储键值对</h3><br><p><strong>之前的键只能用字符串表示，可以用map把对象作为key</strong></p><pre class="line-numbers language-none"><code class="language-none">const obj1&#x3D;&#123;name:&#39;111&#39;&#125;const obj2&#x3D;&#123;name:&#39;222&#39;&#125;const map&#x3D;new Map()map.set(obj1,&#39;aaa&#39;)map.set(obj2,&#39;bbb&#39;)&#x2F;&#x2F;map构造方法const map2&#x3D;new Map([[obj1,&#39;aaa&#39;],[obj2,&#39;bbb&#39;]])&#x2F;&#x2F;[key,value]&#x2F;&#x2F;常见的map方法map.sizemap.set(&#39;key&#39;,&#39;value&#39;)map.get(map.get(&#39;key&#39;)) &#x2F;&#x2F;查看对应属性的值map.has(&#39;key&#39;) &#x2F;&#x2F;判断是否有属性map.delete(&#39;key&#39;) map.clear()&#x2F;&#x2F;支持for of和forEach遍历for(const [key,value] of map)&#123;console.log(key,value)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="weakMap:新增数据类型">weakMap:新增数据类型</h3><br><ul><li>弱引用</li><li>key只能是对象，不能使用基本数据类型，以键值对存在</li><li>不能进行遍历<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;常见方法weakMap.set()weakMap.get()weakMap.has()weakMap.delete()&#x2F;&#x2F;应用场景vue3响应式原理const obj1&#x3D;&#123;name:&#39;why&#39;,  age:18&#125;const obj2&#x3D;&#123;name:&#39;why&#39;,  sex:boy&#125;function obj1NameFun1()&#123;&#125;function obj1NameFun2()&#123;&#125;function obj2NameFun1()&#123;&#125;function obj2NameFun2()&#123;&#125;&#x2F;&#x2F;对象属性发生改变——》改变template——》重新执行render函数——》diff算法——〉渲染&#x2F;&#x2F;最重要的就是把这函数方法和对象关联起来&#x2F;&#x2F;1.创建weakMapconst weakMap&#x3D;new WeakMap()&#x2F;&#x2F;2.收集依赖结构&#x2F;&#x2F;2.1对obj1手机数据结构const obj1Map&#x3D;new Map()obj1Map.set(&#39;name&#39;,[obj1NameFun1,obj1NameFun2])weakMap.set(obj1,obj1Map)&#x2F;&#x2F;2.2对obj2收集数据结构const obj2Map&#x3D;new Map()obj2Map.set(&#39;name&#39;,[obj2NameFun1,obj2NameFun2])weakMap.set(obj2,obj2Map)&#x2F;&#x2F;如果obj.name发生改变，可以通过proxy，defineProperty来监听obj1.name&#x3D;&#39;james&#39;const targetMap&#x3D;weakMap.get(obj1)const fns&#x3D;targetMap.get(&#39;name&#39;)fns.forEach(item&#x3D;&gt;item())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="es7"><a href="#es7" class="headerlink" title="es7"></a>es7</h2><h3 class="bamboo-h " id="includes">includes</h3><br><p>array：includes</p><ul><li>可以判断是否有NaN</li><li>结果是布尔值</li></ul><h3 class="bamboo-h " id="* *">* *</h3><br>  <p><strong>指数运算方法：3* *3 //27</strong></p><h2 id="es8"><a href="#es8" class="headerlink" title="es8"></a>es8</h2><h3 class="bamboo-h " id="对象方法">对象方法</h3><br><ul><li>Object.keys() :<strong>可以获取对象的属性</strong></li><li>Object.values() :<strong>可以获取对象的属性值</strong><br>也可以传入数组，字符串，传入的字符串会解析成一个一个字母在一个新数组中</li><li>object.entries() :<strong>可以获取到一个数组，数组中会存放可每枚举属性的键值对数组</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">const obj&#x3D;&#123;name:&#39;hhx&#39;,  age:12&#125;console.log(Object.entries(obj))&#x2F;&#x2F;1.传入的是对象&#x2F;&#x2F;[[&#39;name&#39;,&#39;hhx&#39;],[&#39;age&#39;,12]]&#x2F;&#x2F;可以通过forEach遍历的方式获取数组每一项进行操作&#x2F;&#x2F;2.传入的是数组console.log(Object.entries([&#39;123&#39;,&#39;456&#39;]))&#x2F;&#x2F;[[&#39;0&#39;,&#39;123&#39;],[&#39;1&#39;,&#39;456&#39;]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="String Padding">String Padding</h3><br><p><strong>String Padding :字符串填充</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;1.padStartconst message &#x3D;&#39;hello&#39;&#x2F;&#x2F;长度填充到几位，没有第二个参数就是默认空格填充message.padStart(15,&#39;*&#39;)&#x2F;&#x2F;2.padEndmessage.padEnd(20,&#39;-&#39;)&#x2F;&#x2F;使用场景const cardNumber&#x3D;&#39;1234123412341234123&#39;const lastNumber&#x3D;cardNumber.slice(-4)lastNumber.padStart(cardNumber.length,&#39;*&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="Object.getOwnPropertyDescriptors">Object.getOwnPropertyDescriptors</h3><br><p>Object.getOwnPropertyDescriptors ：获取对象所有的属性描述符</p><h2 id="es9"><a href="#es9" class="headerlink" title="es9"></a>es9</h2><ul><li>async </li><li>iterators </li><li>展开运算符 </li><li>promise finally</li></ul><h2 id="es10"><a href="#es10" class="headerlink" title="es10"></a>es10</h2><h3 class="bamboo-h " id="flat和flatMap">flat和flatMap</h3><br><pre><code>* flat 降维数组 * flatMap 常应用于函数式编程</code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;flatconst nums&#x3D;[10,20,[2,1],90,[20,[10,6]],3]nums.flat()  &#x2F;&#x2F;默认情况下降维深度是1&#x2F;&#x2F;flatMap，使用映射函数map映射每个元素，将结果压缩成一个新数组const nums2&#x3D;[10,20,30]const nums3&#x3D;nums2.flatMap(item &#x3D;&gt; &#123;return item*2 &#125;)&#x2F;&#x2F;和map结果一样&#x2F;&#x2F;应用场景const message&#x3D;[&#39;hello world&#39;,&#39;hello hhx&#39;,&#39;hello 123&#39;]const words&#x3D;message.flatMap(item &#x3D;&gt;&#123;return item.split(&#39;&#39;)&#125;)console.log(words)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="Object.fromEntries()">Object.fromEntries()</h3><br><p><strong>把entries或者可迭代格式的重新变成obj格式</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;应用场景const queryString&#x3D;&#39;name&#x3D;why&amp;age&#x3D;10&amp;address&#x3D;nqwer&#39;const queryParams&#x3D;new URLSearchParams(queryString)console.log(queryParams)for (const params of queryParams)&#123;console.log(param)&#125; &#x2F;&#x2F;遍历queryParamsconst paramObj&#x3D;Object.fromEntries(queryParams)console.log(paramObj)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="trimStart和trimEnd">trimStart和trimEnd</h3><br><pre class="line-numbers language-none"><code class="language-none">const message&#x3D;&#39;    iaf  &#39;console.log(message.trim())  &#x2F;&#x2F;去除全部空格console.log(message.trimStart())  &#x2F;&#x2F;去除头部空格console.log(message.trimEnd())  &#x2F;&#x2F;去除尾部空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="es11"><a href="#es11" class="headerlink" title="es11"></a>es11</h2><h3 class="bamboo-h " id="BigInt">BigInt</h3><br><p><strong>BigInt:之前只能表示Number.MAX_SAFE_INTEGER大小的数字,超过大小就会导致运算出错，es10引入BigInt进行大数计算</strong></p><pre class="line-numbers language-none"><code class="language-none">const bigInt&#x3D;428938751743923851058n&#x2F;&#x2F;末尾加上n表示是一个大数，进行其他操作的时候其他数也需要加上nconsole.log(bigInt+10n)const num&#x3D;100console.log(bigInt+BigInt(num))&#x2F;&#x2F;把大数转化成number类型const smallNum&#x3D;Number(bigInt)console.log(smallNum)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="空值合并运算">空值合并运算</h3><br><p><strong>空值合并运算: ??</strong></p><pre class="line-numbers language-none"><code class="language-none">const fooconst bar&#x3D;foo || &#39;default value&#39;&#x2F;&#x2F;||的弊端 会把0，‘’当作空置const bar&#x3D;foo ?? &#39;default value&#39; &#x2F;&#x2F;??会明确只判断foo是不是undefined或者null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="可选链">可选链</h3><br><p><strong>可选链：判断对象中的属性是否存在</strong></p><pre class="line-numbers language-none"><code class="language-none">const obj&#x3D;&#123;name:&#39;hhx&#39;,  friends:&#123;  name1:&#39;lilei&#39;,    name2:&#39;hanmeimei&#39;  &#125;&#125;console.log(obj?.friend?.name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="其他">其他</h3><br><ul><li>全局对象<ul><li>浏览器：window</li><li>node：global</li><li>es11新增了关键字：globalThis，在不同的环境下都可以获取全局对象</li></ul></li><li>for in标准化 for key in items </li><li>Dynamic Import 动态导入</li><li>Promise.allSettled</li><li>import meta</li></ul><h2 id="es12"><a href="#es12" class="headerlink" title="es12"></a>es12</h2><h3 class="bamboo-h " id="监听对象的销毁过程">监听对象的销毁过程</h3><br><pre class="line-numbers language-none"><code class="language-none">const finalRegistry&#x3D;new FinalizationRegistry((value)&#x3D;&gt;&#123;console.log(&quot;注册的finalRegistry对象被销毁&quot;,value)&#125;)let obj&#x3D;&#123;name:&#39;hhx&#39;&#125;&#x2F;&#x2F;注册finalRegistry.register(obj,&#39;可以绑定一些值&#39;)obj&#x3D;null&#x2F;&#x2F;gc是不定时销毁垃圾的，所以该finalRegistry函数不会立即执行&#x2F;&#x2F;weakRef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="逻辑赋值运算">逻辑赋值运算</h3><br><ul><li>!!= 逻辑或</li><li>&amp;&amp;= 逻辑与</li><li>??= 逻辑空<pre class="line-numbers language-none"><code class="language-none">let message&#x3D; undefinedmessage &#x3D; message||&#39;default&#39;message ||&#x3D;&#39;default value&#39;let info&#x3D;&#123;name:&#39;hhx&#39;&#125;info&#x3D;info&amp;&amp;info.nameinfo &amp;&amp;&#x3D; info.namelet message &#x3D; &#39;&#39;message ??&#x3D;&#39;default&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> es6——es12 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo</title>
      <link href="/2022/02/13/hexo/"/>
      <url>/2022/02/13/hexo/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>在github上找到了yuang01大佬写的<a href="https://yuang01.gitee.io/">hexo主题</a>进行了我个人博客的搭建，主要是自己知识的总结，在这个过程中也遇到了不少问题，所以想记录一下，也算作我搭建博客的学习心得吧。</p></div><h1 id="hexo搭建博客注意事项"><a href="#hexo搭建博客注意事项" class="headerlink" title="hexo搭建博客注意事项"></a>hexo搭建博客注意事项</h1><p>谷歌了很多资料，发现可以用hexo进行静态搭建博客，我是用hexo把博客放在了我的github上面，网上有很多教程，再次不再多赘述，主要想列举一些在开发过程中遇到的问题。</p><h2 class="bamboo-h " id="一些报错">一些报错</h2><br><h3 id="hexo部署文章到github出现443问题"><a href="#hexo部署文章到github出现443问题" class="headerlink" title="hexo部署文章到github出现443问题"></a><strong>hexo部署文章到github出现443问题</strong></h3><p>当时在部署的时候出现443问题，下面是代码报错实例：</p><pre class="line-numbers language-none"><code class="language-none">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io.git&#x2F;&#39;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 FATAL &#123;  err: Error: Spawn failed      at ChildProcess.&lt;anonymous&gt; (&#x2F;Users&#x2F;kevin&#x2F;Desktop&#x2F;xxx.github.io&#x2F;node_modules&#x2F;hexo-deployer-git&#x2F;node_modules&#x2F;hexo-util&#x2F;lib&#x2F;spawn.js:51:21)      at ChildProcess.emit (events.js:315:20)      at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:277:12) &#123;    code: 128  &#125;&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决办法：</p><ul><li>对_config.yml文件进行修改把deploy的地址从http换成git<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;eg : 以自己为例repository: git@github.com:heelaine&#x2F;heelaine.github.io.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="hexo部署出现TypeError-Cannot-read-property-‘trim’-of-undefined"><a href="#hexo部署出现TypeError-Cannot-read-property-‘trim’-of-undefined" class="headerlink" title="hexo部署出现TypeError: Cannot read property ‘trim’ of undefined"></a><strong>hexo部署出现TypeError: Cannot read property ‘trim’ of undefined</strong></h3><p>这个时候多半是你写入markdown的内容有误，hexo并没有识别出你的内容。<br>解决办法：</p><ul><li>检查文章，是不是出现格式错误或者未知字符，建议写page的时候不要写完再保存，写一段就保存一段，这样找错比较方便。</li></ul><h2 class="bamboo-h " id="格式化">格式化</h2><br><p><strong>最好不要格式化！！</strong><br>相信很多人在开发的时候，会在vscode上面设置自己的格式化规则，我们在下载主题进行配置的时候，也会理所当然直接自动保存格式化，当初我也是这么做的，但是每次一保存就会给我报红，感觉自己改的没有问题，一保存就出错真的很心累，后来才找到原因，因为我自己设置的格式化会改变它原来主题的代码格式导致hexo不能正常运行，我关了之后再去改代码就方便多了。</p><h2 class="bamboo-h " id="图片路径">图片路径</h2><br><pre class="line-numbers language-none"><code class="language-none">$ npm install hexo-image-link --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在编写个人博客的时候，通常会想要插入自己想要的图片，hexo的文章编写是通过markdown的格式来实现的，我们在这里就可以用markdown的格式来插入图片!(图片描述)[图片路径]，但是图片路径需要注意。<br>解决办法：</p><ul><li>下载<strong>hexo-image-link</strong>包;</li><li>修改**_config.yml<strong>中的</strong>post_asset_folder: true**。资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] <title> 命令创建新文章时自动创建一个同名文件夹。</title></li><li>通过markdown的方式引入图片，这里只需要引入相对路径即可。<pre class="line-numbers language-none"><code class="language-none">![服务器和客户端传输过程](1.png) &#x2F;&#x2F;第一个括号是图片描述&#x2F;&#x2F;第二个括号是同名文件夹的图片名字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>一般情况下图片都能正常显示了，但是我发现我的图片还是裂开的并不能正常显示，我去检查我页面元素图片路径，发现路径有几段是重复的，这个时候只需要设置_config.yml的url就可以了<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;eg : 以自己为例url: https:&#x2F;&#x2F;heelaine.github.io&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>这样操作下来就可以发现页面能正常显示图片，并且图片路径也是正确的了。</li></ul><h2 class="bamboo-h " id="CDN图床">CDN图床</h2><br><p>因为个人博客可能会有很多需要图片的地方，但是如果一股脑都放在本地里，由于国内访问github总是时不时抽风且怕本地资源过于冗杂，所以我尝试通过外链的方式进行引用图片。<br><strong>图床</strong>：就是专门提供存储图片的地方，有收费也有免费的，他会帮助我们进行图片的管理和优化，比如多机互备、CDN 加速、图片处理、图片鉴黄、文本识别等等。我使用的是<a href="https://itunes.apple.com/cn/app/id1101244278?mt=12">ipic</a> 工具，免费版默认是微博图床。<br><strong>用法</strong>（主要讲解的mac用户，window应该也差不多）：</p><ol><li>下载ipic工具并安装</li><li>桌面顶部菜单就会出现ipic图标<br>!()[ipic.jpg]</li><li>点击图标选择markdown，把需要的图片拖拽到图标上</li><li>这个时候图标上就会显示你需要上传的图片，单击图片就是复制图片链接</li></ol><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;eg: 以自己为例![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;008i3skNgy1gz8uyzff92j30u0140gr7.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="note warning"><p>可能有些人对CDN不是很了解，我也是在这次搭建过程中加深了我对cdn的理解，我们可以把cdn理解成快递点，当我们需要访问服务器上的资源的时候，有可能会遇到网站加载速度慢，资源出不来，高延迟等等问题，我们通常会通过cdn的方式进行加速，你想要访问什么资源就去最近的快递点去拿快递——最近的cdn节点获取资源，这样也能解决服务器的压力。具体的cdn的知识大家可以google一下～</p></div><h2 class="bamboo-h " id="jsDelivr + Github">jsDelivr + Github</h2><br><p>如果用惯github的人，也可以通过<span class="pbg yellow">jsDelivr+github</span>的方式。<br><strong>jsDelivr</strong>：一个免费的cdn，支持npm，GitHub，wordpress等等。<br>解决办法：</p><ol><li>在github上创建一个仓库</li><li>把图片等静态资源push到仓库里</li><li>插入图片的地方需要修改链接<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;eg : 以自己为例![图片描述](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;用户名&#x2F;仓库名&#x2F;文件地址)![图片描述](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;heelaine&#x2F;PersonalSource&#x2F;img&#x2F;lxb&#x2F;line5_2.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><span class="pbg yellow">这种方式也能实现cdn对图片的加速</span>  </li></ol><h2 class="bamboo-h " id="生成page的模版">生成page的模版</h2><br><p>在scaffolds文件夹中放置的是你生成new page的模版，默认生成的是post.md文件的模版，可以通过修改 <strong>_config.yml</strong>中的 <strong>default_layout</strong> 参数来指定默认布局。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;eg : 以自己的为例---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: helainetags:categories:---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;命令：默认生成post模版hexo n  &#39;文章名字&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo注意事项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise</title>
      <link href="/2022/02/13/promise/"/>
      <url>/2022/02/13/promise/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这一part主要关于js中的promise，包括promise的基本api和用法，还有如何手写一个promise</p></div><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>当我们进行网络请求的时候，一般进行的都是异步操作，封装的请求函数如果想要拿到请求结果，不能用return，因为异步操作获取不到结果，之前我们经常使用回调函数来进行解决。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;伪代码function requestData(url,successCb,failureCb)&#123;  setTimeout(()&#x3D;&gt;&#123;  if()&#123;      &#x2F;&#x2F;成功,就走成功的回调      successCb()     &#125;else&#123;     &#x2F;&#x2F;失败，就走失败的回调       failureCb()     &#125;  &#125;,3000)&#125;requestData(&#39;hhx&#39;,(res)&#x3D;&gt;&#123;成功的处理&#125;,(res)&#x3D;&gt;&#123;失败的处理&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="回调函数的弊端">回调函数的弊端</h2><br><ul><li>如果是我们自己封装的请求的函数，要自己设计成功回调和失败回调</li><li>如果使用的是别人封装和第三方库，必须看别人的源码才能知道使用方法<br>—————所以这个时候就诞生了<strong>promise</strong></li></ul><p>1.promise规范好了所有的代码编写逻辑，它会返回一个promise，可以直接使用。<br>2.promise是一个类，当返回回调数据的时候，就可以创建一个promise对象，通过new创建promise对象，需要传入一个回调函数，称之为<span class="pbg yellow">executor</span>，异步请求代码会被放入<span class="pbg yellow">executor</span>中。</p><ul><li>这个回调函数会被立即执行，并且传入另外两个回调函数resolve，reject</li><li>当调用resolve，执行promise对象的<strong>then方法</strong>传入的回调函数</li><li>当调用reject，执行promise对象的<strong>catch</strong>方法传入的回调函数</li></ul><p><strong>三个状态，状态一旦确定就无法更改。</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;伪代码function foo()&#123;return new Promise((resolve,reject)&#x3D;&gt;&#123;    &#x2F;&#x2F;进行异步请求的时候在这里面写，比如网络请求    &#x2F;&#x2F;resolve()  reject()  &#125;)&#125;const fooPromise&#x3D;foo()&#x2F;&#x2F;then方法传入的回调函数，会在promise执行resolve函数时，被回调fooPromise.then(()&#x3D;&gt;&#123;&#125;)&#x2F;&#x2F;catch方法传入的回调函数，会在promise执行reject函数时，被回调fooPromise.catch(()&#x3D;&gt;&#123;&#125;)&#x2F;&#x2F;then方法可以传入两个回调，一个成功一个失败&#x2F;&#x2F;模拟网络请求function foo(url)&#123;return new Promise((resolve,reject)&#x3D;&gt;&#123;    setTimeout((url)&#x3D;&gt;&#123;  if(url&#x3D;&#x3D;&#x3D;&#39;hhx&#39;)&#123;      &#x2F;&#x2F;成功,就走成功的回调      let name&#x3D;[&#39;123&#39;,&#39;456&#39;]      resolve(name)     &#125;else&#123;     &#x2F;&#x2F;失败，就走失败的回调       let err&#x3D;&#39;请求失败&#39;       reject(err)     &#125;  &#125;,3000)  reject()  &#125;)&#125;const fooPromise&#x3D;foo()fooPromise.then((res)&#x3D;&gt;&#123;  console.log(res)&#125;,(err)&#x3D;&gt;&#123;console.log(err)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="resolve的详解">resolve的详解</h2><br><p><strong>resolve参数</strong><br>1.普通的值或者对象<br>2.传入一个promise，那么当前的promise的状态会由当前传入的promise来决定，相当于状态进行了移交<br>3.如果传入一个对象，并且这个对象有个then方法，会直接执行then方法，状态由then来改变</p><pre class="line-numbers language-none"><code class="language-none">const newPromise &#x3D;new Promise((resolve,reject)&#x3D;&gt;&#123;&#125;)&#x2F;&#x2F;传入一个promisenew Promise((resolve,reject)&#x3D;&gt;&#123;  resolve(newPromise)&#125;).then(()&#x3D;&gt;&#123;&#125;,()&#x3D;&gt;&#123;&#125;)&#x2F;&#x2F;传入一个对象，并且这个对象有then方法new Promise((resolve,reject)&#x3D;&gt;&#123;  const obj&#x3D;&#123;  then:function(resolve,reject)&#123;    resolve()    &#125;  &#125;resolve(obj)&#125;).then((res)&#x3D;&gt;&#123;console.log(res)&#125;,(err)&#x3D;&gt;&#123;console.log(err)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="promise对象方法">promise对象方法</h2><br><h3 class="bamboo-h " id="then方法">then方法</h3><br><span class="pbg yellow">promise.then()</span><pre><code>对象的方法，其实是放在**Promise.prototype.then()**</code></pre><p>1.同一个promise可以多次调用then方法，当我们的resolve方法被回调的时候，所有的then方法传入的回调函数都会被调用<br>2.then方法传入的回调函数可以有返回值，<span class="pbg yellow">他的返回值是新的promise</span>——promise链式调用的实质<br>    2.1如果返回普通值，那么普通的值会被作为一个新的promise的resolve值，做对应的回调，如果没有返回默认返回值是undefined<br>    2.2如果返回promise，那么返回的promise的状态会决定下一个then里面的状态<br>    2.3如果返回一个对象，并且该对象实现了thenable，那么thenable里面状态会决定下一个then里面的状态</p><pre class="line-numbers language-none"><code class="language-none">const promise &#x3D;new Promise((resolve,reject)&#x3D;&gt;&#123;resolve(&#39;hahaha&#39;)&#125;)promise.then(res&#x3D;&gt;&#123;console.log(res)&#125;)promise.then(res&#x3D;&gt;&#123;console.log(res)&#125;)&#x2F;&#x2F;hahaha hahahapromise.then(res&#x3D;&gt;&#123;  return &#39;aaa&#39;&#125;).then(res&#x3D;&gt;&#123;console.log(res)&#125;)&#x2F;&#x2F;aaapromise.then(res&#x3D;&gt;&#123;  return &#123;  then:function(resolve,reject)&#123;    resolve(1111)    &#125;  &#125;&#125;).then(res&#x3D;&gt;&#123;console.log(res)&#125;)&#x2F;&#x2F;1111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="catch方法">catch方法</h3><br><p><strong>catch方法的本质就是then方法的语法糖。</strong><br>then方法有两个参数，第一个是成功的回调，第二个是失败的回调，catch相当于执行第二个参数的回调<br>1.当executor(主函数)抛出异常的时候，也是会调用错误捕获的回调函数<br>2.通过catch方法来传入错误捕获的回调函数<br>3.拒绝捕获的问题<br>4.catch方法的返回值也是一个promise</p><pre class="line-numbers language-none"><code class="language-none">const promise&#x3D;new Promise((resolve,reject)&#x3D;&gt;&#123;reject(&#39;请求失败&#39;)  &#x2F;&#x2F;throw new Error(&#39;请求失败&#39;)&#125;)&#x2F;&#x2F;1.promise.then(undefined,(err)&#x3D;&gt;&#123;console.log(err)  &#x2F;&#x2F;当抛出错误的时候，err就是错误信息&#125;)&#x2F;&#x2F;2.promise.catch(err&#x3D;&gt;&#123;console.log(err)&#125;)&#x2F;&#x2F;或者promise.then(res&#x3D;&gt;&#123;&#125;).catch(err&#x3D;&gt;&#123;&#125;)&#x2F;&#x2F;catch默认情况下针对的是第一个promise而不是then返回的新的promise&#x2F;&#x2F;如果第一个promise没有异常，第二个promise有异常，catch也会捕获return&#x2F;&#x2F;出来的promise，如果第一个第二个peomise都有异常会先捕获第一个异常&#x2F;&#x2F;3.promise.then()promise.catch()&#x2F;&#x2F;会报错，因为then并没有针对reject进行处理&#x2F;&#x2F;可以通过链式调用。then。catch的方法或者then里面写两个函数的方法来解决<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="finally方法">finally方法</h3><br><ul><li>无论promise是什么状态都会执行。</li><li>finally方法不接受参数。</li></ul><h2 class="bamboo-h " id="promise类方法">promise类方法</h2><br><h3 id="resolve方法"><a href="#resolve方法" class="headerlink" title="resolve方法"></a>resolve方法</h3><p><strong>特点：</strong>把普通对象转化成promise对象</p><pre class="line-numbers language-none"><code class="language-none">const promise&#x3D;Promise.resolve(&#123;name:&#39;hhx&#39;&#125;)promise.then(res&#x3D;&gt;&#123;console.log(res)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="reject方法"><a href="#reject方法" class="headerlink" title="reject方法"></a>reject方法</h3><p><strong>特点：</strong>无论传入什么值都是一样的</p><pre class="line-numbers language-none"><code class="language-none">const promise&#x3D;Promise.reject(&#39;失败&#39;)&#x2F;&#x2F;相当于const promise&#x3D;new Promise((resolve,reject)&#x3D;&gt;&#123;reject(&#39;失败&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><p>1.首先创建多个promise<br>2.然后把所有的promise都变成fulfilled，再拿到结果<br><strong>特点：</strong><br>1.拿到的结果按照顺序返回<br>2.如果有一个变成rejected，那么整个都变成rejected</p><pre class="line-numbers language-none"><code class="language-none">const p1&#x3D;new Promise((resolve)&#x3D;&gt;&#123;resolve(111)&#125;)const p2&#x3D;new Promise((resolve)&#x3D;&gt;&#123;resolve(222)&#125;)const p3&#x3D;new Promise((resolve)&#x3D;&gt;&#123;resolve(333)&#125;)Promise.all([p1,p2,p3,&#39;aaa&#39;]).then(res&#x3D;&gt;&#123;console.log(res)&#125;).catch(err&#x3D;&gt;&#123;console.log(err)&#125;)&#x2F;&#x2F;[111,222,333,&#39;aaa&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="allSettled方法"><a href="#allSettled方法" class="headerlink" title="allSettled方法"></a>allSettled方法</h3><p><strong>特点：</strong>等到所有promise都有结果，无论是成功还是失败。</p><pre class="line-numbers language-none"><code class="language-none">const p1&#x3D;new Promise((resolve)&#x3D;&gt;&#123;resolve(111)&#125;)const p2&#x3D;new Promise((reject)&#x3D;&gt;&#123;reject(222)&#125;)const p3&#x3D;new Promise((resolve)&#x3D;&gt;&#123;resolve(333)&#125;)Promise.allSettled([p1,p2,p3]).then((res)&#x3D;&gt;&#123;console.log(res)&#125;).catch((err)&#x3D;&gt;&#123;console.log(err)&#125;)&#x2F;&#x2F;返回值一个数组里面有对象[  &#123;status:&#39;fulfilled&#39;,value:111&#125;,  &#123;status:&#39;rejected&#39;,reason:222&#125;,  &#123;status:&#39;fulfilled&#39;,value:333&#125;,]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h3><p><strong>特点：</strong>只要有一个promise执行变成fulfilled，那么就结束。如果有一个拒绝，那么就返回拒绝的结果。</p><pre class="line-numbers language-none"><code class="language-none">Promise.race([p1,p2,p3]).then((res)&#x3D;&gt;&#123;console.log(res)&#125;).catch((err)&#x3D;&gt;&#123;console.log(err)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="any方法"><a href="#any方法" class="headerlink" title="any方法"></a>any方法</h3><p><strong>特点：</strong>至少等到一个promise变成fulfilled，如果都拒绝，等到所有执行promise在执行catch。</p><pre class="line-numbers language-none"><code class="language-none">Promise.any([p1,p2,p3]).then((res)&#x3D;&gt;&#123;console.log(res)&#125;).catch((err)&#x3D;&gt;&#123;console.log(err,err.errors)  &#x2F;&#x2F;可以通过errors拿到对应的错误&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="手写promise">手写promise</h2><br><h3 id="简单粗暴版"><a href="#简单粗暴版" class="headerlink" title="简单粗暴版"></a>简单粗暴版</h3><p>1.类的设计：通过class的方法<br>2.保存promise的状态，保存reject和resolve的参数<br>3.解决then的第一个回调函数，解决then的第二个回调函数<br>4.绑定定时器避免还没有调用then的时候，就不能执行onFulfilled和onreject函数，但是定时器是宏任务，promise是微任务，所以可以用<span class="pbg yellow">queueMicrotask</span>。</p><pre class="line-numbers language-none"><code class="language-none">const PROMISE_STATUS_PENDING&#x3D;&#39;pending&#39;const PROMISE_STATUS_FULFILLED&#x3D;&#39;fulfilled&#39;const PROMISE_STATUS_REJECTED&#x3D;&#39;rejected&#39;class DiyPromise&#123;constructor(executor)&#123;    this.status&#x3D;PROMISE_STATUS_PENDING  &#x2F;&#x2F;promise的状态    this.value&#x3D;undefined &#x2F;&#x2F;保存reject和resolve里面的参数    this.reason&#x3D;undefined  const resolve&#x3D;(value)&#x3D;&gt;&#123;      if(this.status &#x3D;&#x3D;&#x3D; PROMISE_STATUS_PENDING)&#123;        setTimeout(()&#x3D;&gt;&#123;          this.status&#x3D;PROMISE_STATUS_FULFILLED          this.value&#x3D;value          console.log(&#39;resolve调用&#39;)          this.onFulfilled(this.value)        &#125;,0)      &#125;    &#125;    const reject&#x3D;(reason)&#x3D;&gt;&#123;    if(this.status &#x3D;&#x3D;&#x3D; PROMISE_STATUS_PENDING)&#123;        setTimeout(()&#x3D;&gt;&#123;        this.status&#x3D;PROMISE_STATUS_REJECTED          this.reason&#x3D;reason          console.log(&#39;reject调用&#39;)          this.onRejected(this.value)        &#125;,0)      &#125;    &#125;    executor(resolve,reject)  &#125;  then(onFulfilled,onRejected)&#123;  &#x2F;&#x2F;on一般表示在什么状态就执行对应的函数    this.onFulfilled&#x3D;onFulfilled    this.onRejected&#x3D;onRejected  &#125;&#125;const promise &#x3D;new DiyPromise((resolve,reject)&#x3D;&gt;&#123;reject()    resolve()&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="改良版1-0"><a href="#改良版1-0" class="headerlink" title="改良版1.0"></a>改良版1.0</h3><p><strong>方法的优化</strong><br>1.实现then多次调用<br>2.确定promise状态之后再次调用then<br>3.promise的then的链式调用  ——&gt;then方法返回promise</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;then不能调用多次const PROMISE_STATUS_PENDING&#x3D;&#39;pending&#39;const PROMISE_STATUS_FULFILLED&#x3D;&#39;fulfilled&#39;const PROMISE_STATUS_REJECTED&#x3D;&#39;rejected&#39;class DiyPromise&#123;constructor(executor)&#123;    this.status&#x3D;PROMISE_STATUS_PENDING  &#x2F;&#x2F;promise的状态    this.value&#x3D;undefined &#x2F;&#x2F;保存reject和resolve里面的参数    this.reason&#x3D;undefined    this.onFulfilledFns&#x3D;[] &#x2F;&#x2F;把回调的方法放数组里然后遍历去执行    this.onRejectedFns&#x3D;[]    const resolve&#x3D;(value)&#x3D;&gt;&#123;      if(this.status &#x3D;&#x3D;&#x3D; PROMISE_STATUS_PENDING)&#123;        &#x2F;&#x2F;添加微任务        queueMicrotask(()&#x3D;&gt;&#123;          &#x2F;&#x2F;如果状态不等于pending就不执行          if(this.status!&#x3D;&#x3D;PROMISE_STATUS_PENDING) return           this.status&#x3D;PROMISE_STATUS_FULFILLED          this.value&#x3D;value          console.log(&#39;resolve调用&#39;)          this.onFulfilledFns.forEach(fn&#x3D;&gt;&#123;          fn(this.value)          &#125;)        &#125;)      &#125;    &#125;    const reject&#x3D;(reason)&#x3D;&gt;&#123;    if(this.status &#x3D;&#x3D;&#x3D; PROMISE_STATUS_PENDING)&#123;        &#x2F;&#x2F;添加微任务        queueMicrotask(()&#x3D;&gt;&#123;          &#x2F;&#x2F;如果状态不等于pending就不执行          if(this.status!&#x3D;&#x3D;PROMISE_STATUS_PENDING) return         this.status&#x3D;PROMISE_STATUS_REJECTED          this.reason&#x3D;reason          console.log(&#39;reject调用&#39;)          this.onRejectedFns.forEach(fn&#x3D;&gt;&#123;          fn(this.reason)          &#125;)        &#125;)      &#125;    &#125;    try&#123;      executor(resolve,reject)    &#125;catch(err)&#123;      reject(err)    &#125;      &#125;  then(onFulfilled,onRejected)&#123;     return new DiyPromise((resolve,reject)&#x3D;&gt;&#123;    &#x2F;&#x2F;1.如果then调用的时候，状态已经确定下来,比如在定时器里调用promise。then方法      if(this.status&#x3D;&#x3D;&#x3D;PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled)&#123;        try&#123;        const value &#x3D;onFulfilled(this.value)          resolve(value)        &#125;catch(err)&#123;        reject(err)        &#125;           &#125;      if(this.status&#x3D;&#x3D;&#x3D;PROMISE_STATUS_REJECTED &amp;&amp; onRejected)&#123;        try&#123;        const reason &#x3D; onRejected(this.reason)          resolve(reason)        &#125;catch(err)&#123;        reject(err)        &#125;           &#125;      &#x2F;&#x2F;2.当状态是pending的时候      &#x2F;&#x2F;在传入的时候进行参数的判断，未空的时候进行处理，将成功的回调和失败的回调放到数组里      if(this.status&#x3D;&#x3D;&#x3D;PROMISE_STATUS_PENDING)&#123;          this.onFulfilledFns.push(()&#x3D;&gt;&#123;            try&#123;              const value &#x3D;onFulfilled(this.value)              resolve(value)            &#125;catch(err)&#123;              reject(err)            &#125;            &#125;)          this.onRejectedFns.push(()&#x3D;&gt;&#123;          try&#123;              const reason &#x3D;onRejected(this.value)              resolve(reason)            &#125;catch(err)&#123;              reject(err)            &#125;            &#125;)      &#125;    &#125;)  &#125;&#125;const promise &#x3D;new DiyPromise((resolve,reject)&#x3D;&gt;&#123;reject()  resolve()&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>因为try，catch重复代码太多可以进行封装抽取</strong></p><h3 id="改良版2-0"><a href="#改良版2-0" class="headerlink" title="改良版2.0"></a>改良版2.0</h3><p>1.封装try和catch<br>2.实现对象方法和类方法</p><pre class="line-numbers language-none"><code class="language-none">const PROMISE_STATUS_PENDING&#x3D;&#39;pending&#39;const PROMISE_STATUS_FULFILLED&#x3D;&#39;fulfilled&#39;const PROMISE_STATUS_REJECTED&#x3D;&#39;rejected&#39;&#x2F;&#x2F;工具函数function execFunctionWithCatchErr(execFn,value,resolve,reject)&#123;  try&#123;    const result &#x3D;execFn(value)    resolve(result)  &#125;catch(err)&#123;    reject(err)  &#125; &#125;class DiyPromise&#123;constructor(executor)&#123;    this.status&#x3D;PROMISE_STATUS_PENDING  &#x2F;&#x2F;promise的状态    this.value&#x3D;undefined &#x2F;&#x2F;保存reject和resolve里面的参数    this.reason&#x3D;undefined    this.onFulfilledFns&#x3D;[] &#x2F;&#x2F;把回调的方法放数组里然后遍历去执行    this.onRejectedFns&#x3D;[]        const resolve&#x3D;(value)&#x3D;&gt;&#123;      if(this.status &#x3D;&#x3D;&#x3D; PROMISE_STATUS_PENDING)&#123;        &#x2F;&#x2F;添加微任务        queueMicrotask(()&#x3D;&gt;&#123;          &#x2F;&#x2F;如果状态不等于pending就不执行          if(this.status!&#x3D;&#x3D;PROMISE_STATUS_PENDING) return           this.status&#x3D;PROMISE_STATUS_FULFILLED          this.value&#x3D;value          console.log(&#39;resolve调用&#39;)          this.onFulfilledFns.forEach(fn&#x3D;&gt;&#123;          fn(this.value)          &#125;)        &#125;)      &#125;    &#125;    const reject&#x3D;(reason)&#x3D;&gt;&#123;    if(this.status &#x3D;&#x3D;&#x3D; PROMISE_STATUS_PENDING)&#123;        &#x2F;&#x2F;添加微任务        queueMicrotask(()&#x3D;&gt;&#123;          &#x2F;&#x2F;如果状态不等于pending就不执行          if(this.status!&#x3D;&#x3D;PROMISE_STATUS_PENDING) return         this.status&#x3D;PROMISE_STATUS_REJECTED          this.reason&#x3D;reason          console.log(&#39;reject调用&#39;)          this.onRejectedFns.forEach(fn&#x3D;&gt;&#123;          fn(this.reason)          &#125;)        &#125;)      &#125;    &#125;    try&#123;      executor(resolve,reject)    &#125;catch(err)&#123;      reject(err)    &#125;      &#125;  then(onFulfilled,onRejected)&#123;    &#x2F;&#x2F;catch封装，当then里没有第二个参数的时候，由catch接收err    onRejected&#x3D;onRejected|| (err&#x3D;&gt;&#123;throw err&#125;)    &#x2F;&#x2F;当执行finally中间有rejected的时候，catch用的是then方法接受的第一个参数不是undefined，要把value给return出去    onFulfilled&#x3D;onRejected|| (value&#x3D;&gt;&#123;return value&#125;)        return new DiyPromise((resolve,reject)&#x3D;&gt;&#123;    &#x2F;&#x2F;1.如果then调用的时候，状态已经确定下来,比如在定时器里调用promise。then方法      if(this.status&#x3D;&#x3D;&#x3D;PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled)&#123;        execFunctionWithCatchErr(onFulfilled,this.value,resolve,reject)      &#125;      if(this.status&#x3D;&#x3D;&#x3D;PROMISE_STATUS_REJECTED &amp;&amp; onRejected)&#123;        execFunctionWithCatchErr(onFulfilled,this.reason,resolve,reject)          &#125;      &#x2F;&#x2F;2.当状态是pending的时候      &#x2F;&#x2F;在传入的时候进行参数的判断，未空的时候进行处理，将成功的回调和失败的回调放到数组里      if(this.status&#x3D;&#x3D;&#x3D;PROMISE_STATUS_PENDING)&#123;        if(onFulfilled)&#123;          this.onFulfilledFns.push(()&#x3D;&gt;&#123;            execFunctionWithCatchErr(onFulfilled,this.value,resolve,reject)          &#125;)        &#125;   if(onRejected)&#123;        this.onRejectedFns.push(()&#x3D;&gt;&#123;          execFunctionWithCatchErr(onFulfilled,this.reason,resolve,reject)           &#125;)        &#125;       &#125;    &#125;)  &#125;  &#x2F;&#x2F;catch方法的封装  catch(onRejected)&#123;  return this.then(undefined,onRejected)  &#125;  &#x2F;&#x2F;finally方法的封装  finally(onFinally)&#123;  this.then(()&#x3D;&gt;&#123;      onFinally()    &#125;,()&#x3D;&gt;&#123;    onFinally()    &#125;)  &#125;    &#x2F;&#x2F;resolve和reject方法  static resolve(value)&#123;  return new DiyPromise((resolve)&#x3D;&gt;resolve(value))  &#125;  static reject(reason)&#123;  return new DiyPromise((resolve,reject)&#x3D;&gt;reject(reason))  &#125;    &#x2F;&#x2F;all方法  static all(promises)&#123;    &#x2F;&#x2F;什么时候执行resolve和reject  return new DiyPromise((resolve,reject)&#x3D;&gt;&#123;    const values&#x3D;[]      promises.forEach(promise&#x3D;&gt;&#123;      promise.then(res&#x3D;&gt;&#123;        values.push(res)          if(values.length&#x3D;&#x3D;&#x3D;promises.length)&#123;          resolve(values)          &#125;        &#125;,err&#x3D;&gt;&#123;        reject(err)        &#125;)      &#125;)    &#125;)  &#125;  &#x2F;&#x2F;allSettled  static allSettled(promises)&#123;  return new DiyPromise((resolve)&#x3D;&gt;&#123;    const results&#x3D;[]      promises.forEach(promise&#x3D;&gt;&#123;      promise.then(res&#x3D;&gt;&#123;        results.push(&#123;status:PROMISE_STATUS_FULFILLED,value:res&#125;)          if(results.length&#x3D;&#x3D;&#x3D;promises.length)&#123;          resolve(results)          &#125;        &#125;,err&#x3D;&gt;&#123;        results.push(&#123;status:PROMISE_STATUS_REJECTED,value:err&#125;)          if(results.length&#x3D;&#x3D;&#x3D;promises.length)&#123;          resolve(results)          &#125;        &#125;)      &#125;)    &#125;)  &#125;    &#x2F;&#x2F;race  static race(promises)&#123;  return new DiyPromise((resolve,reject)&#x3D;&gt;&#123;            &#x2F;&#x2F;笨办法      promises.forEach(promise&#x3D;&gt;&#123;      promise.then(res&#x3D;&gt;&#123;          resolve(res)        &#125;,err&#x3D;&gt;&#123;        reject(err)        &#125;)      &#125;)       &#x2F;&#x2F;回调它本身      promises.forEach(promise&#x3D;&gt;&#123;      promise.then(resolve,reject)      &#125;)    &#125;)  &#125;    &#x2F;&#x2F;any  static any()&#123;    const reasons&#x3D;[]  return new DiyPromise((resolve,reject)&#x3D;&gt;&#123;      promises.forEach(promise&#x3D;&gt;&#123;      promise.then(resolve,err&#x3D;&gt;&#123;      reasons.push(err)        if(reasons.length&#x3D;&#x3D;&#x3D;promises.length)&#123;        reject(new AggregateError(reasons))        &#125;      &#125;)       &#125;)    &#125;)   &#125;   &#125;const promise &#x3D;new DiyPromise((resolve,reject)&#x3D;&gt;&#123;reject(111)  &#x2F;&#x2F;resolve(222)&#125;)promise.then(res&#x3D;&gt;&#123;console.log(&#39;res1&#39;,res)  return &#39;aaa&#39;&#125;,(err)&#x3D;&gt;&#123;console.log(&#39;err1&#39;,err)  return &#39;bbb&#39;&#125;).then(res&#x3D;&gt;&#123;console.log(&#39;res2&#39;,res)&#125;,(err)&#x3D;&gt;&#123;console.log(&#39;err1&#39;,err)  return &#39;bbb&#39;&#125;)promise.then(res&#x3D;&gt;&#123;console.log(res)&#125;).catch(err&#x3D;&gt;&#123;console.log(err)&#125;).finally(()&#x3D;&gt;&#123;console.log(&#39;finally&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="promise手写总结">promise手写总结</h2><br><p>1.promise的规范： <a href="https://promisesaplus.com/">promisea+规范官网</a>。<br>2.promise类的设计：class 的方式也可以使用function的方式<br>3.构造函数的规划：</p><pre class="line-numbers language-none"><code class="language-none">constructor()&#123;    &#x2F;&#x2F;定义状态    &#x2F;&#x2F;定义resolve，reject回调    &#x2F;&#x2F;resolve执行微任务队列，改变状态，获取value，then传入执行回调    &#x2F;&#x2F;reject执行微任务队列，改变状态，获取reason，then传入执行回调    &#x2F;&#x2F;try catch    executor(resolve,reject)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.then方法的实现</p><pre class="line-numbers language-none"><code class="language-none">then(onFulfilled,onRejected)&#123;    &#x2F;&#x2F;this.onFulfilled&#x3D;onFulfilled    &#x2F;&#x2F;this.onRejected&#x3D;onRejected  ——最简单的实现    &#x2F;&#x2F;1.判断穿进的参数是否有值，给地默认值    &#x2F;&#x2F;2.返回promise resolve &#x2F;reject    &#x2F;&#x2F;3.判断之前的promise的状态是否确定 确定的话直接执行    &#x2F;&#x2F;4.添加到数组中push(（）&#x3D;&gt;执行 onFulfilled&#x2F;onRejected 直接执行代码)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.catch方法</p><pre class="line-numbers language-none"><code class="language-none">catch(onRejected)&#123;    return this.then(undefined,onRejected)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>6.finally方法</p><pre class="line-numbers language-none"><code class="language-none">finally(onFinally)&#123;    return this.then(()&#x3D;&gt;&#123;        onFinally()        &#125;,()&#x3D;&gt;&#123;        onFinally()    &#125;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7.reject/resolve<br>8.all/allSettled<br><strong>重点：要知道搭配resolve和reject什么时候执行</strong><br>all：<br>1.所有的都有结果<br>2.有一个reject<br><strong>allSettled：所有的都有结果，并且一定执行resolve</strong><br>9.race/any<br>race：只要有结果，就返回<br>any：<br>1.必须等到一个resolve结果<br>2.都没有resolve，所有的都是reject</p>]]></content>
      
      
      <categories>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识this并手写call，apply和bind</title>
      <link href="/2022/02/10/this/"/>
      <url>/2022/02/10/this/</url>
      
        <content type="html"><![CDATA[<h2 class="bamboo-h " id="认识this">认识this</h2><br><div class="note info"><p>在全局作用域中，不同的环境的this有不同的指向。</p></div><pre><code>浏览器——&gt;window;node——&gt;&#123;&#125;</code></pre><p><strong>ps</strong>:在node环境中，每个js脚本都被当成一个module,module——&gt;加载——&gt;编译——&gt;找到一个函数——&gt;执行这个函数.call({})</p><ul><li>this是执行上下文中的一条记录。</li><li>this是动态绑定的，在函数执行的时候才绑定。</li><li>this指向跟函数所处的位置没有关系，跟函数被调用的方式有关。</li></ul><h2 class="bamboo-h " id="this的绑定规则">this的绑定规则</h2><br><p><strong>1.默认绑定？函数独立调用的时候！</strong></p><span class="pbg yellow">指向全局作用域</span><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;案例一function foo1()&#123;    console.log(this);&#125;function foo2()&#123;    console.log(this)    foo1()&#125;function foo3()&#123;    console.log(this)    foo2()&#125;foo3()&#x2F;&#x2F;三个window对象&#x2F;&#x2F;案例二var obj &#x3D; &#123;  name: &quot;hhx&quot;,  foo: function () &#123;    console.log(this);  &#125;,&#125;;var bar &#x3D; obj.foo;bar();&#x2F;&#x2F;window对象&#x2F;&#x2F;案例三function foo()&#123;console.log(this)&#125;var obj &#x3D; &#123;  name: &quot;hhx&quot;,  foo: foo&#125;;var bar &#x3D; obj.foo;bar();&#x2F;&#x2F;window对象&#x2F;&#x2F;案例五function foo()&#123;function bar()&#123;  console.log(this)  &#125;  return bar&#125;var fn&#x3D;foo()fn() &#x2F;&#x2F;window对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.隐式绑定？通过对象调用！</strong></p><div class="note warning"><p>必须在调用的对象内部有一个对函数的引用，没有引用的话，在调用的时候，会报找不到该函数的错误。</p></div><p>eg：obj.fn()  </p><pre class="line-numbers language-none"><code class="language-none">var obj&#x3D;&#123;foo:function()&#123;  console.log(this.name)  &#125;&#125;var obj2&#x3D;&#123;name:&#39;obj2&#39;,  bar:obj.foo&#125;obj2.bar()&#x2F;&#x2F;打印的是name:obj2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.显式绑定？call apply bind</strong></p><span class="pbg yellow">foo直接调用和call/apply调用的不同在于this的绑定不同foo</span>,<span class="pbg yellow">直接调用指向的是全局对象</span><pre class="line-numbers language-none"><code class="language-none">function foo()&#123;console.log(&#39;函数被调用了&#39;,this.name)&#125;var obj&#x3D;&#123;name:&#39;hhx&#39;&#125;foo.call(obj)foo.apply(obj)&#x2F;&#x2F;hhx&#x2F;&#x2F;call和apply在执行函数的时候可以指定this的绑定对象，显式绑定&#x2F;&#x2F;call、apply的区别&#x2F;&#x2F;call传参的时候用逗号隔开&#x2F;&#x2F;apply通过数组来传参数function foo()&#123;console.log(this)&#125;&#x2F;&#x2F;foo.call(&#39;a&#39;)var newFoo&#x3D;foo.bind(&#39;a&#39;)newFoo()  &#x2F;&#x2F;通过bind绑定this到字符串a上，会产生一个新的函数需要调用一下。&#x2F;&#x2F;默认绑定和显示绑定冲突的时候，显示绑定的优先级更高。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4.new绑定？使用new关键字！</strong><br>1.创建一个新对象<br>2.新对象执行prototype连接<br>3.把新对象绑定到函数调用的this上<br>4.如果函数没有返回其他对象，表达式会返回这个新对象</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;通过new关键字构造一个函数，这个时候this是在调用构造器时创造出来的对象function Person(name,age)&#123;this.name&#x3D;name  this.age&#x3D;age&#125;var p1&#x3D;new Person(&#39;hhx&#39;,18)console.log(p1.name,p1.age)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="this和内置函数的关系">this和内置函数的关系</h2><br><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;案例一setTimeout(function()&#123;console.log(this)&#125;,2000)&#x2F;&#x2F;这里面的this指向window&#x2F;&#x2F;案例二 监听点击事件box.onclick&#x3D;function()&#123;console.log(this)&#125;&#x2F;&#x2F;相当于 box.onclick()&#x2F;&#x2F;打印结果是box这个元素box.addEventListener(&#39;click&#39;,function()&#123;console.log(this)&#125;)&#x2F;&#x2F;相当于显示绑定 call 打印结果是box这个元素&#x2F;&#x2F;案例三var team&#x3D;[&#39;abc&#39;,&#39;dem&#39;]team.forEach(function()&#123;console.log(this)&#125;,&#39;123&#39;)&#x2F;&#x2F;结果 ‘123’ ‘123’&#x2F;&#x2F;有些函数内部会有参数可以让你去绑定相对应的this&#x2F;&#x2F;如果默认不写绑定的就是全局window对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="this绑定规则的优先级">this绑定规则的优先级</h2><br><p>1.独立调用优先级最低。<br>2.显示绑定的优先级高于隐式绑定，包括apply，call，bind。<br>3.new绑定优先级高于隐式绑定。<br>4.new的优先级高于显示绑定，new关键字不能和apply，call一起使用。</p><span class="pbg yellow">例子</span><pre class="line-numbers language-none"><code class="language-none">function foo()&#123;console.log(this)&#125;var bar&#x3D;foo.bind(&#39;aaa&#39;)var obj&#x3D;new bar()console.log(obj)&#x2F;&#x2F;打印结果是foo()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="note warning"><p>有些语法超过我们的规则之外</p></div><p><strong>1.忽略显示绑定</strong></p><pre class="line-numbers language-none"><code class="language-none">function foo()&#123;console.log(this)&#125;foo.apply(null)foo.apply(undefined)&#x2F;&#x2F;如果显示绑定绑定的是null，undefined的时候，会自动将this绑定成全局对象。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.间接函数引用</strong></p><pre class="line-numbers language-none"><code class="language-none">var obj1&#x3D;&#123;foo:function()&#123;  console.log(this)  &#125;&#125;var obj2 &#x3D; &#123;  name:&#39;obj2&#39;&#125;;(obj2.bar&#x3D;obj1.foo)()&#x2F;&#x2F;在这里认为是独立函数的运用&#x3D;&#x3D;foo()&#x2F;&#x2F;指向window<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span class="pbg yellow">ps如果一行没有加分号</span>,<span class="pbg yellow">意味着代码还没有结束</span>,<span class="pbg yellow">会跟下面的代码连起来一起执行</span>。<pre class="line-numbers language-none"><code class="language-none">function foo(el)&#123;console.log(el,this.id)&#125;var obj&#x3D;&#123;id:&#39;hhx&#39;&#125;[1,2,3].forEach(foo,obj)&#x2F;&#x2F;会直接报错&#x2F;&#x2F;需要添加括号或者把123数组赋值给一个新数组 var nums&#x3D;[1，2，3]&#x2F;&#x2F;结果是1 hhx 2 hhx 3 hhx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.箭头函数</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;3.1 箭头函数不能绑定<span class="pbg yellow">this</span>，<span class="pbg yellow">arguments</span>，<span class="pbg yellow">不能使用构造函数（new）</span>。<br>&nbsp;&nbsp;&nbsp;&nbsp;3.2 简写规则：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个箭头函数，只有一行代码，并且返回一个对象？怎么简写<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var bar=() =&gt;  ({ name:’hhx’, age : ‘13’})  利用小括号～<br>&nbsp;&nbsp;&nbsp;&nbsp;3.3 箭头函数的this，根据外层作用域来查找this。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;定义对象的时候并没有定义作用域,定义函数的时候会有作用域var name&#x3D;&#39;hhx&#39;var obj&#x3D;&#123;  name:&#39;123&#39;foo:()&#x3D;&gt; console.log(this.name)foo1:function()&#123;  return function()&#123;    console.log(this.name)    &#125;  &#125;foo2:function()&#123;  return ()&#x3D;&gt;&#123;    console.log(this.name)    &#125;  &#125;&#125;var obj2&#x3D;&#123;name:&#39;456&#39;&#125;obj.foo() &#x2F;&#x2F; hhx 打印的是windowobj.foo1()() &#x2F;&#x2F;hhx 打印的是window 把它放做独立函数调用，因为相当于里面的函数单独调用执行obj.foo2()() &#x2F;&#x2F;123 箭头函数不绑定this，上级作用域的this是objobj.foo2.call(obj2)() &#x2F;&#x2F;456 上层作用域绑定了一个obj2obj.foo2().call(obj2) &#x2F;&#x2F;123 上层作用域找到obj&#x2F;&#x2F;this 1:52:25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="手写绑定this函数">手写绑定this函数</h2><br><h3 class="bamboo-h " id="实现call">实现call</h3><br><p><strong>实现call思路</strong><br>1.首先要获取到需要被执行的函数<br>2.对thisArg转换成对象类型 ，防止传入的是非对象类型，null和undefined的话默认为window<br>3.对额外参数进行接收并处理<br>4.调用需要被执行的函数<br>5.将最终的结果返回出去</p><pre class="line-numbers language-none"><code class="language-none">Function.prototype.selfCall&#x3D;function(thisArg,...args)&#123;    &#x2F;&#x2F;首先要获取到需要被执行的函数    &#x2F;&#x2F;通过this来获取函数    var fn&#x3D;this &#x2F;&#x2F;this指向被调用的函数    &#x2F;&#x2F;调用被执行函数    &#x2F;&#x2F;fn()    thisArg &#x3D; thisArg ? Object(thisArg) : window    thisArg.fn&#x3D;fn    var result&#x3D;thisArg.fn(...args)    &#x2F;&#x2F;如果直接执行是默认调用 会把this绑定到window上，所以可以通过中间值把函数绑定到thisArg上    &#x2F;&#x2F;会导致对象上多出一个fn属性    delete thisArg.fn    &#x2F;&#x2F;上面的...args是对参数的简写，表示除第一个参数外其他的所有参数    &#x2F;&#x2F;下面的...args是值扩展运算符，就不用一一传入参数内容    return result&#125;function foo()&#123;console.log(&#39;执行了foo函数&#39;,this)&#125;&#x2F;&#x2F;默认进行了隐式绑定foo.selfCall()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="实现apply">实现apply</h3><br><p><strong>实现思路和call一样</strong></p><pre class="line-numbers language-none"><code class="language-none">Function.prototype.selfApply&#x3D;function(thisArg,args)&#123;&#x2F;&#x2F;因为apply传入的是数组，只有一个参数，所以不需要。。。    &#x2F;&#x2F;在call用的是...args,默认没有参数，该args为空[]    var fn&#x3D;this    thisArg &#x3D;        thisArg !&#x3D;&#x3D; null &amp;&amp; thisArg !&#x3D;&#x3D; undefined ? Object(thisArg) : window;    &#x2F;&#x2F;进行优化，如果传入的是0    thisArg.fn&#x3D;fn    &#x2F;&#x2F;需要对传进来的参数进行判断    args&#x3D;args||[]    var result&#x3D;thisArg.fn(args)    delete thisArg.fn    return result&#125;function foo()&#123;console.log(&#39;执行了foo函数&#39;,this)&#125;foo.selfApply()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="实现bind">实现bind</h3><br><pre class="line-numbers language-none"><code class="language-none">Function.prototype.selfBind&#x3D;function(thisArg,...args)&#123;&#x2F;&#x2F;1.获取到真实需要调用的函数    var fn&#x3D;this    &#x2F;&#x2F;2.绑定this    thisArg &#x3D;        thisArg !&#x3D;&#x3D; null &amp;&amp; thisArg !&#x3D;&#x3D; undefined ? Object(thisArg) : window;    return function(...arg1)&#123;        &#x2F;&#x2F;3.将函数放到thisArg中调用        thisArg.fn&#x3D;fn        &#x2F;&#x2F;4.对两个传入的参数进行合并        var finalArgs&#x3D;[...args,...arg1]        var result&#x3D;thisArg.fn(...finalArgs)        delete thisArg.fn        &#x2F;&#x2F;5.返回结果        return result  &#125;&#125;function foo()&#123;console.log(&#39;执行了foo函数&#39;,this)&#125;var bar&#x3D;foo.selfBind()bar()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> this相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp&amp;udp</title>
      <link href="/2022/02/10/tcp-udp/"/>
      <url>/2022/02/10/tcp-udp/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>在了解tcp和udp之前，可以先对计算机网络做一些简单的了解。</p></div><h2 class="bamboo-h " id="网络模型">网络模型</h2><br><p><strong>五层模型</strong>：</p><ul><li>物理层</li><li>数据链路层</li><li>网络层  (主机之间通信)</li><li>传输层  (应用程序间通信)</li><li>应用层 </li></ul><p><strong>七层模型</strong>：</p><ul><li>物理层</li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>会话层，表示层，应用层</li></ul><p><strong>传输过程中文件会被拆分成多个数据包来传输</strong></p><wavy>补充：</wavy><ul><li>mac地址：也称物理地址(硬件地址)，由网络设备制造商生产时写在硬件内部，无论接到哪个网络，都拥有相同的mac地址。</li><li>IP：IP数据报送到目的主机(主机之间的逻辑通信)，计算机的地址就是ip地址 访问网站就是你的计算机向另外一台计算机请求信息,但是IP只负责传送到对方电脑，不知道哪个程序，所以在发送前会加上主机的ip地址。</li><li>UDP：用户数据包协议 （通过端口号UDP把指定数据包发送给程序）（应用程序之间通信）</li></ul><span class="pbg yellow">udp</span>对于<span class="pbg yellow">错误的数据包</span>：udp不重发，直接丢弃当前的包，并且udp发送之后不知道能不能到达目的地。<br><span class="pbg yellow">udp的问题</span>：1.数据包容易丢失。2.大文件拆分成小数据包传输的时候不知道如何组装这些数据包，把他们还原成完整的文件。<br><p>而<span class="pbg yellow">tcp</span>解决了udp的问题 ：如果数据包丢失的话就重传。tcp引入了<span class="pbg yellow">数据包排序机制</span>，把打乱的数据包组合成完整的文件。所以tcp头包含了<strong>目标端口</strong>和<strong>本机端口</strong>，还提供了<strong>排序的序列号</strong>。(TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度)。所以tcp是一种<span class="pbg yellow">面向连接</span>，<span class="pbg yellow">可靠的</span>，<span class="pbg yellow">基于字节流</span>的传输层通信协议。</p><h2 class="bamboo-h " id="浏览器和服务器交互过程">浏览器和服务器交互过程</h2><br><p><img src="/2022/02/10/tcp-udp/1.png" class="lazyload placeholder" data-srcset="/2022/02/10/tcp-udp/1.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="服务器和客户端传输过程"><br><strong>首先，建立连接阶段。</strong>这个阶段是通过“<span class="pbg yellow">三次握手</span>”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送<span class="pbg yellow">三个数据包</span>以确认连接的建立。<br><strong>其次，传输数据阶段。</strong>在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，<span class="pbg yellow">在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制</span>。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。<br><strong>最后，断开连接阶段。</strong>数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。</p><h2 class="bamboo-h " id="TCP和UDP的不同">TCP和UDP的不同</h2><br><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>可靠的</td><td>不可靠的</td></tr><tr><td>面向连接的</td><td>无连接的</td></tr><tr><td>传输效率低</td><td>传输效率高</td></tr><tr><td>对系统资源要求高</td><td>对系统资源要求低</td></tr><tr><td>少量数据</td><td>大量数据</td></tr><tr><td>每次连接只有两个端点</td><td>支持一对一，一对多，多对多</td></tr><tr><td>拥塞控制，网络拥塞会导致效率变低</td><td>没有拥塞控制</td></tr><tr><td>面向字节流，根据对方的窗口之和网络拥塞程度来决定报文段包含多少字节，如果数据块太长，可以划分短一点在传送</td><td>面向报文，一次性交付一个完整报文。</td></tr><tr><td>提供双全工通信，在发送和接受都设置缓存，临时存放数据</td><td></td></tr></tbody></table><h2 class="bamboo-h " id="三次握手">三次握手</h2><br><p><img src="/2022/02/10/tcp-udp/2.png" class="lazyload placeholder" data-srcset="/2022/02/10/tcp-udp/2.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="三次握手"><br><strong>第一次握手</strong><br>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 <span class="pbg yellow">SYN-SENT</span> 状态。<br><strong>第二次握手</strong><br>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入<span class="pbg yellow">SYN-RECEIVED</span>  状态。<br><strong>第三次握手</strong><br>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入了<span class="pbg yellow">ESTABLISHED</span>  状态，服务端收到这个应答后也进入 <span class="pbg yellow">ESTABLISHED</span> 状态，此时连接建立成功。</p><wavy>只有两次怎么办？</wavy><p>如果只有 2 次的话，服务器并不清楚浏览器是否收到他发过去的信息，可能会一直发送消息。</p><h2 class="bamboo-h " id="四次挥手">四次挥手</h2><br><p><img src="/2022/02/10/tcp-udp/3.png" class="lazyload placeholder" data-srcset="/2022/02/10/tcp-udp/3.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="四次挥手"><br><strong>第一次挥手</strong><br>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。<br><strong>第二次挥手</strong><br>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 <span class="pbg yellow">CLOSE_WAIT</span> 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。<br><strong>第三次挥手</strong><br>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入<span class="pbg yellow">LAST-ACK</span>  状态。<br><strong>PS</strong>：通过延迟确认的技术(通常有时间限制，否则对方会误认为需要重传)，可以将第二次和第三次握手合并，延迟 ACK 包的发送。<br><strong>第四次挥手</strong><br>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 <span class="pbg yellow">TIME-WAIT</span> 状态。该状态会持续 2MSL(最长报文段寿命，指报文段在网络中生存的时间，超时会被抛弃) 时间，若该时间段内没有 B 的重发请求的话，就进入 <span class="pbg yellow">CLOSED</span> 状态。当 B 收到确认应答后，也便进入 <span class="pbg yellow">CLOSED</span> 状态。</p><h2 id="http和TCP的关系"><a href="#http和TCP的关系" class="headerlink" title="http和TCP的关系"></a>http和TCP的关系</h2><p>TCP 协议对应于传输层，而 HTTP 协议对应于应用层，从本质上来说，二者没有可比性：</p><ul><li>HTTP 对应于应用层，TCP 协议对应于传输层</li><li>HTTP 是无状态的短连接，而 TCP 是有状态的长连接</li><li>HTTP 协议是在 TCP 协议之上建立的，HTTP 在发起请求时通过 TCP 协议建立起连接服务器的通道，请求结束后，立即断开 TCP 连接</li><li>TCP是传输层协议，定义的是数据传输和连接方式的规范，HTTP是应用层协议，定义的是传输数据的内容的规范。<br><img src="/2022/02/10/tcp-udp/4.png" class="lazyload placeholder" data-srcset="/2022/02/10/tcp-udp/4.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="过程"></li></ul>]]></content>
      
      
      <categories>
          
          <category> tcp&amp;udp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是加密算法？</title>
      <link href="/2022/02/09/jiami/"/>
      <url>/2022/02/09/jiami/</url>
      
        <content type="html"><![CDATA[<h2 class="bamboo-h " id="浏览器加密">浏览器加密</h2><br><div class="note info"><p>浏览器的安全一直以来是人们关注的问题，为了让网上的信息不被泄漏，做出了很多努力，其中主要包括对称加密，非对称加密，以及两种加密结合的方式。</p></div><h2 class="bamboo-h " id="对称加密">对称加密</h2><br><p><img src="/2022/02/09/jiami/1.jpg" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/1.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="对称加密"></p><emp>思考</emp> ：<p>&nbsp;&nbsp;1.浏览器和服务器双方如何拿到钥匙？<br>&nbsp;&nbsp;2.传输钥匙会不会被截获，别人也能拿到钥匙？  </p><h2 class="bamboo-h " id="非对称加密">非对称加密</h2><br><p><img src="/2022/02/09/jiami/2.jpg" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/2.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="非对称加密"></p><wavy>好处：</wavy>  第三方就算截获了公钥和加密消息也没用，因为没有私钥，不能获取消息。  <br><emp>思考</emp> ：非对称加密非常耗时，怎么解决？<br><h2 class="bamboo-h " id="对称加密+非对称加密">对称加密+非对称加密</h2><br><p><img src="/2022/02/09/jiami/3.jpg" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/3.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="对称加密+非对称加密"></p><wavy>好处：</wavy>  这样双方都可以得到安全的对称加密的钥匙，虽然公钥是明文传输的但是只要私钥被自己保管，所以可以保证钥匙的安全。这样就可以用钥匙(对称加密)进行消息的加密了。也解决了多次非对称加密的产生的时间损耗问题。  <br><emp>思考</emp> ：如果中间人获取公钥之后，发送了自己的公钥，那他就能破解浏览器用他的公钥加密之后的密钥，他还能把密钥用刚才获取的公钥进行加密发送给服务器，这样双方都不会发觉密钥已经泄漏了。<br><div class="note warning"><p>经过这几步操作，其实还是逃不过一个问题，如何证明你的身份，也就是说怎么证明公钥是你的？</p></div><p class="p center large blue">那就是数字证书！！</p><p><img src="/2022/02/09/jiami/4.jpg" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/4.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="数字证书"><br>    1.CA机构拥有非对称加密的私钥和公钥。 <br>    2.CA机构对证书明文数据T进行hash。 <br>    3.对hash后的值用私钥加密，得到数字签名S。<br>    4.数字签名+明文数据=数字证书<br><img src="/2022/02/09/jiami/5.jpg" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/5.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="浏览器验证"><br>    1.浏览器拿到证书，得到明文T，签名S。<br>    2.用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥）得到S’。<br>    3.用证书里指明的hash算法对明文T进行hash得到T’。<br>    4.显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。<br>    5.所以此时比较S’是否等于T’，等于则表明证书可信。</p><p class="p warning">中间人有可能篡改该证书吗？</p><p>&nbsp;&nbsp;假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</p><p class="p warning">既然不可能篡改，那整个证书被掉包呢？</p><p>&nbsp;&nbsp;假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？<strong>但是</strong>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。<br>&nbsp;&nbsp;<strong>操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。</strong></p><div class="note info"><p>数据被哈希的原因：因为非对称加密比较耗时，但是hash之后得到的是固定长度的信息，这样加解密比较方便。非对称加密可以加密的消息体长度有上限，必须先hash保证定长结果。</p></div><p><img src="/2022/02/09/jiami/image.png" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/image.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="完整流程"><br>&nbsp;&nbsp;ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。 这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中。<br><img src="/2022/02/09/jiami/ca.png" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/ca.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="CA证书"></p>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序章</title>
      <link href="/2022/01/16/hello-world/"/>
      <url>/2022/01/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>静态服务器搭建的博客</p><h2 id="人的进步在于承认自己的不足"><a href="#人的进步在于承认自己的不足" class="headerlink" title="人的进步在于承认自己的不足"></a>人的进步在于承认自己的不足</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>2022-01-16 23:51</p><h3 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h3><p>地球某处</p><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><p>序章</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>以前总觉得学习是一种被推着走的过程，从小学到高中，囫囵吞枣的接受着老师或外界灌输的知识，或死记或硬背，为了高考这一目标而前进，等真正到了大学没有人再推着你的时候，身后的压力突然消失，自己也变得茫然，肚子里的那点墨水根本不是自己想要了解的，抑或是和别人聊天时，才发现自己错过了很多学习的时机，所以想通过这种个人网站的方式来记录，或许人会随着时间消失，但知识不会，也有可能我现在所记录的也是以后别人学习的材料……总而言之，读万卷书，行万里路，各位一起进步吧。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
