<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>promise</title>
      <link href="/2022/02/13/promise/"/>
      <url>/2022/02/13/promise/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>这一part主要关于js中的promise，包括promise的基本api和用法，还有如何手写一个promise</p></div><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>当我们进行网络请求的时候，一般进行的都是异步操作，封装的请求函数如果想要拿到请求结果，不能用return，因为异步操作获取不到结果，之前我们经常使用回调函数来进行解决。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;伪代码function requestData(url,successCb,failureCb)&#123;  setTimeout(()&#x3D;&gt;&#123;  if()&#123;      &#x2F;&#x2F;成功,就走成功的回调      successCb()     &#125;else&#123;     &#x2F;&#x2F;失败，就走失败的回调       failureCb()     &#125;  &#125;,3000)&#125;requestData(&#39;hhx&#39;,(res)&#x3D;&gt;&#123;成功的处理&#125;,(res)&#x3D;&gt;&#123;失败的处理&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="回调函数的弊端">回调函数的弊端</h2><br><ul><li>如果是我们自己封装的请求的函数，要自己设计成功回调和失败回调</li><li>如果使用的是别人封装和第三方库，必须看别人的源码才能知道使用方法<br>—————所以这个时候就诞生了<strong>promise</strong></li></ul><p>1.promise规范好了所有的代码编写逻辑，它会返回一个promise，可以直接使用。<br>2.promise是一个类，当返回回调数据的时候，就可以创建一个promise对象，通过new创建promise对象，需要传入一个回调函数，称之为<span class="pbg yellow">executor</span>，异步请求代码会被放入<span class="pbg yellow">executor</span>中。</p><ul><li>这个回调函数会被立即执行，并且传入另外两个回调函数resolve，reject</li><li>当调用resolve，执行promise对象的<strong>then方法</strong>传入的回调函数</li><li>当调用reject，执行promise对象的<strong>catch</strong>方法传入的回调函数</li><li>*三个状态，状态一旦确定就无法更改**。<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;伪代码function foo()&#123;return new Promise((resolve,reject)&#x3D;&gt;&#123;    &#x2F;&#x2F;进行异步请求的时候在这里面写，比如网络请求    &#x2F;&#x2F;resolve()  reject()  &#125;)&#125;const fooPromise&#x3D;foo()&#x2F;&#x2F;then方法传入的回调函数，会在promise执行resolve函数时，被回调fooPromise.then(()&#x3D;&gt;&#123;&#125;)&#x2F;&#x2F;catch方法传入的回调函数，会在promise执行reject函数时，被回调fooPromise.catch(()&#x3D;&gt;&#123;&#125;)&#x2F;&#x2F;then方法可以传入两个回调，一个成功一个失败&#x2F;&#x2F;模拟网络请求function foo(url)&#123;return new Promise((resolve,reject)&#x3D;&gt;&#123;    setTimeout((url)&#x3D;&gt;&#123;  if(url&#x3D;&#x3D;&#x3D;&#39;hhx&#39;)&#123;      &#x2F;&#x2F;成功,就走成功的回调      let name&#x3D;[&#39;123&#39;,&#39;456&#39;]      resolve(name)     &#125;else&#123;     &#x2F;&#x2F;失败，就走失败的回调       let err&#x3D;&#39;请求失败&#39;       reject(err)     &#125;  &#125;,3000)  reject()  &#125;)&#125;const fooPromise&#x3D;foo()fooPromise.then((res)&#x3D;&gt;&#123;  console.log(res)&#125;,(err)&#x3D;&gt;&#123;console.log(err)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="resolve的详解">resolve的详解</h2><br></li><li><em>resolve参数</em>*</li></ul><p>1.普通的值或者对象<br>2.传入一个promise，那么当前的promise的状态会由当前传入的promise来决定，相当于状态进行了移交<br>3.如果传入一个对象，并且这个对象有个then方法，会直接执行then方法，状态由then来改变</p><pre class="line-numbers language-none"><code class="language-none">const newPromise &#x3D;new Promise((resolve,reject)&#x3D;&gt;&#123;&#125;)&#x2F;&#x2F;传入一个promisenew Promise((resolve,reject)&#x3D;&gt;&#123;  resolve(newPromise)&#125;).then(()&#x3D;&gt;&#123;&#125;,()&#x3D;&gt;&#123;&#125;)&#x2F;&#x2F;传入一个对象，并且这个对象有then方法new Promise((resolve,reject)&#x3D;&gt;&#123;  const obj&#x3D;&#123;  then:function(resolve,reject)&#123;    resolve()    &#125;  &#125;resolve(obj)&#125;).then((res)&#x3D;&gt;&#123;console.log(res)&#125;,(err)&#x3D;&gt;&#123;console.log(err)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="promise对象方法">promise对象方法</h2><br><h3 class="bamboo-h " id="then方法">then方法</h3><br><span class="pbg yellow">promise.then()</span><pre><code>对象的方法，其实是放在&#123;% pbg yellow ,Promise.prototype.then() %&#125;</code></pre><p>1.同一个promise可以多次调用then方法，当我们的resolve方法被回调的时候，所有的then方法传入的回调函数都会被调用<br>2.then方法传入的回调函数可以有返回值，<span class="pbg yellow">他的返回值是新的promise</span>——promise链式调用的实质<br>    2.1如果返回普通值，那么普通的值会被作为一个新的promise的resolve值，做对应的回调，如果没有返回默认返回值是undefined<br>    2.2如果返回promise，那么返回的promise的状态会决定下一个then里面的状态<br>    2.3如果返回一个对象，并且该对象实现了thenable，那么thenable里面状态会决定下一个then里面的状态</p><pre class="line-numbers language-none"><code class="language-none">const promise &#x3D;new Promise((resolve,reject)&#x3D;&gt;&#123;resolve(&#39;hahaha&#39;)&#125;)promise.then(res&#x3D;&gt;&#123;console.log(res)&#125;)promise.then(res&#x3D;&gt;&#123;console.log(res)&#125;)&#x2F;&#x2F;hahaha hahahapromise.then(res&#x3D;&gt;&#123;  return &#39;aaa&#39;&#125;).then(res&#x3D;&gt;&#123;console.log(res)&#125;)&#x2F;&#x2F;aaapromise.then(res&#x3D;&gt;&#123;  return &#123;  then:function(resolve,reject)&#123;    resolve(1111)    &#125;  &#125;&#125;).then(res&#x3D;&gt;&#123;console.log(res)&#125;)&#x2F;&#x2F;1111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="catch方法">catch方法</h3><br><p><strong>catch方法的本质就是then方法的语法糖。</strong><br>then方法有两个参数，第一个是成功的回调，第二个是失败的回调，catch相当于执行第二个参数的回调<br>1.当executor(主函数)抛出异常的时候，也是会调用错误捕获的回调函数<br>2.通过catch方法来传入错误捕获的回调函数<br>3.拒绝捕获的问题<br>4.catch方法的返回值也是一个promise</p><pre class="line-numbers language-none"><code class="language-none">const promise&#x3D;new Promise((resolve,reject)&#x3D;&gt;&#123;reject(&#39;请求失败&#39;)  &#x2F;&#x2F;throw new Error(&#39;请求失败&#39;)&#125;)&#x2F;&#x2F;1.promise.then(undefined,(err)&#x3D;&gt;&#123;console.log(err)  &#x2F;&#x2F;当抛出错误的时候，err就是错误信息&#125;)&#x2F;&#x2F;2.promise.catch(err&#x3D;&gt;&#123;console.log(err)&#125;)&#x2F;&#x2F;或者promise.then(res&#x3D;&gt;&#123;&#125;).catch(err&#x3D;&gt;&#123;&#125;)&#x2F;&#x2F;catch默认情况下针对的是第一个promise而不是then返回的新的promise&#x2F;&#x2F;如果第一个promise没有异常，第二个promise有异常，catch也会捕获return&#x2F;&#x2F;出来的promise，如果第一个第二个peomise都有异常会先捕获第一个异常&#x2F;&#x2F;3.promise.then()promise.catch()&#x2F;&#x2F;会报错，因为then并没有针对reject进行处理&#x2F;&#x2F;可以通过链式调用。then。catch的方法或者then里面写两个函数的方法来解决<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="finally方法">finally方法</h3><br><ul><li>无论promise是什么状态都会执行。</li><li>finally方法不接受参数。</li></ul><h2 class="bamboo-h " id="promise类方法">promise类方法</h2><br><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><p><strong>特点：</strong>把普通对象转化成promise对象</p><pre class="line-numbers language-none"><code class="language-none">const promise&#x3D;Promise.resolve(&#123;name:&#39;hhx&#39;&#125;)promise.then(res&#x3D;&gt;&#123;console.log(res)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><p><strong>特点：</strong>无论传入什么值都是一样的</p><pre class="line-numbers language-none"><code class="language-none">const promise&#x3D;Promise.reject(&#39;失败&#39;)&#x2F;&#x2F;相当于const promise&#x3D;new Promise((resolve,reject)&#x3D;&gt;&#123;reject(&#39;失败&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h3><p>1.首先创建多个promise<br>2.然后把所有的promise都变成fulfilled，再拿到结果<br><strong>特点：</strong><br>1.拿到的结果按照顺序返回<br>2.如果有一个变成rejected，那么整个都变成rejected</p><pre class="line-numbers language-none"><code class="language-none">const p1&#x3D;new Promise((resolve)&#x3D;&gt;&#123;resolve(111)&#125;)const p2&#x3D;new Promise((resolve)&#x3D;&gt;&#123;resolve(222)&#125;)const p3&#x3D;new Promise((resolve)&#x3D;&gt;&#123;resolve(333)&#125;)Promise.all([p1,p2,p3,&#39;aaa&#39;]).then(res&#x3D;&gt;&#123;console.log(res)&#125;).catch(err&#x3D;&gt;&#123;console.log(err)&#125;)&#x2F;&#x2F;[111,222,333,&#39;aaa&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="allSettled方法"><a href="#allSettled方法" class="headerlink" title="allSettled方法"></a>allSettled方法</h3><p><strong>热点：</strong>等到所有promise都有结果，无论是成功还是失败。</p><pre class="line-numbers language-none"><code class="language-none">const p1&#x3D;new Promise((resolve)&#x3D;&gt;&#123;resolve(111)&#125;)const p2&#x3D;new Promise((reject)&#x3D;&gt;&#123;reject(222)&#125;)const p3&#x3D;new Promise((resolve)&#x3D;&gt;&#123;resolve(333)&#125;)Promise.allSettled([p1,p2,p3]).then((res)&#x3D;&gt;&#123;console.log(res)&#125;).catch((err)&#x3D;&gt;&#123;console.log(err)&#125;)&#x2F;&#x2F;返回值一个数组里面有对象[  &#123;status:&#39;fulfilled&#39;,value:111&#125;,  &#123;status:&#39;rejected&#39;,reason:222&#125;,  &#123;status:&#39;fulfilled&#39;,value:333&#125;,]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h3><p><strong>特点：</strong>只要有一个promise执行变成fulfilled，那么就结束。如果有一个拒绝，那么就返回拒绝的结果。</p><pre class="line-numbers language-none"><code class="language-none">Promise.race([p1,p2,p3]).then((res)&#x3D;&gt;&#123;console.log(res)&#125;).catch((err)&#x3D;&gt;&#123;console.log(err)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="any方法"><a href="#any方法" class="headerlink" title="any方法"></a>any方法</h3><p><strong>特点：</strong>至少等到一个promise变成fulfilled，如果都拒绝，等到所有执行promise在执行catch。</p><pre class="line-numbers language-none"><code class="language-none">Promise.any([p1,p2,p3]).then((res)&#x3D;&gt;&#123;console.log(res)&#125;).catch((err)&#x3D;&gt;&#123;console.log(err,err.errors)  &#x2F;&#x2F;可以通过errors拿到对应的错误&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="手写promise">手写promise</h2><br><h3 id="简单粗暴版"><a href="#简单粗暴版" class="headerlink" title="简单粗暴版"></a>简单粗暴版</h3><p>1.类的设计：通过class的方法<br>2.保存promise的状态，保存reject和resolve的参数<br>3.解决then的第一个回调函数，解决then的第二个回调函数<br>4.绑定定时器避免还没有调用then的时候，就不能执行onFulfilled和onreject函数，但是定时器是宏任务，promise是微任务，所以可以用<span class="pbg yellow">queueMicrotask</span>。</p><pre class="line-numbers language-none"><code class="language-none">const PROMISE_STATUS_PENDING&#x3D;&#39;pending&#39;const PROMISE_STATUS_FULFILLED&#x3D;&#39;fulfilled&#39;const PROMISE_STATUS_REJECTED&#x3D;&#39;rejected&#39;class DiyPromise&#123;constructor(executor)&#123;    this.status&#x3D;PROMISE_STATUS_PENDING  &#x2F;&#x2F;promise的状态    this.value&#x3D;undefined &#x2F;&#x2F;保存reject和resolve里面的参数    this.reason&#x3D;undefined  const resolve&#x3D;(value)&#x3D;&gt;&#123;      if(this.status &#x3D;&#x3D;&#x3D; PROMISE_STATUS_PENDING)&#123;        setTimeout(()&#x3D;&gt;&#123;          this.status&#x3D;PROMISE_STATUS_FULFILLED          this.value&#x3D;value          console.log(&#39;resolve调用&#39;)          this.onFulfilled(this.value)        &#125;,0)      &#125;    &#125;    const reject&#x3D;(reason)&#x3D;&gt;&#123;    if(this.status &#x3D;&#x3D;&#x3D; PROMISE_STATUS_PENDING)&#123;        setTimeout(()&#x3D;&gt;&#123;        this.status&#x3D;PROMISE_STATUS_REJECTED          this.reason&#x3D;reason          console.log(&#39;reject调用&#39;)          this.onRejected(this.value)        &#125;,0)      &#125;    &#125;    executor(resolve,reject)  &#125;  then(onFulfilled,onRejected)&#123;  &#x2F;&#x2F;on一般表示在什么状态就执行对应的函数    this.onFulfilled&#x3D;onFulfilled    this.onRejected&#x3D;onRejected  &#125;&#125;const promise &#x3D;new DiyPromise((resolve,reject)&#x3D;&gt;&#123;reject()    resolve()&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="改良版1-0"><a href="#改良版1-0" class="headerlink" title="改良版1.0"></a>改良版1.0</h3><p><strong>方法的优化</strong><br>1.实现then多次调用<br>2.确定promise状态之后再次调用then<br>3.promise的then的链式调用  ——》then方法返回promise</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;then不能调用多次const PROMISE_STATUS_PENDING&#x3D;&#39;pending&#39;const PROMISE_STATUS_FULFILLED&#x3D;&#39;fulfilled&#39;const PROMISE_STATUS_REJECTED&#x3D;&#39;rejected&#39;class DiyPromise&#123;constructor(executor)&#123;    this.status&#x3D;PROMISE_STATUS_PENDING  &#x2F;&#x2F;promise的状态    this.value&#x3D;undefined &#x2F;&#x2F;保存reject和resolve里面的参数    this.reason&#x3D;undefined    this.onFulfilledFns&#x3D;[] &#x2F;&#x2F;把回调的方法放数组里然后遍历去执行    this.onRejectedFns&#x3D;[]    const resolve&#x3D;(value)&#x3D;&gt;&#123;      if(this.status &#x3D;&#x3D;&#x3D; PROMISE_STATUS_PENDING)&#123;        &#x2F;&#x2F;添加微任务        queueMicrotask(()&#x3D;&gt;&#123;          &#x2F;&#x2F;如果状态不等于pending就不执行          if(this.status!&#x3D;&#x3D;PROMISE_STATUS_PENDING) return           this.status&#x3D;PROMISE_STATUS_FULFILLED          this.value&#x3D;value          console.log(&#39;resolve调用&#39;)          this.onFulfilledFns.forEach(fn&#x3D;&gt;&#123;          fn(this.value)          &#125;)        &#125;)      &#125;    &#125;    const reject&#x3D;(reason)&#x3D;&gt;&#123;    if(this.status &#x3D;&#x3D;&#x3D; PROMISE_STATUS_PENDING)&#123;        &#x2F;&#x2F;添加微任务        queueMicrotask(()&#x3D;&gt;&#123;          &#x2F;&#x2F;如果状态不等于pending就不执行          if(this.status!&#x3D;&#x3D;PROMISE_STATUS_PENDING) return         this.status&#x3D;PROMISE_STATUS_REJECTED          this.reason&#x3D;reason          console.log(&#39;reject调用&#39;)          this.onRejectedFns.forEach(fn&#x3D;&gt;&#123;          fn(this.reason)          &#125;)        &#125;)      &#125;    &#125;    try&#123;      executor(resolve,reject)    &#125;catch(err)&#123;      reject(err)    &#125;      &#125;  then(onFulfilled,onRejected)&#123;     return new DiyPromise((resolve,reject)&#x3D;&gt;&#123;    &#x2F;&#x2F;1.如果then调用的时候，状态已经确定下来,比如在定时器里调用promise。then方法      if(this.status&#x3D;&#x3D;&#x3D;PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled)&#123;        try&#123;        const value &#x3D;onFulfilled(this.value)          resolve(value)        &#125;catch(err)&#123;        reject(err)        &#125;           &#125;      if(this.status&#x3D;&#x3D;&#x3D;PROMISE_STATUS_REJECTED &amp;&amp; onRejected)&#123;        try&#123;        const reason &#x3D; onRejected(this.reason)          resolve(reason)        &#125;catch(err)&#123;        reject(err)        &#125;           &#125;      &#x2F;&#x2F;2.当状态是pending的时候      &#x2F;&#x2F;在传入的时候进行参数的判断，未空的时候进行处理，将成功的回调和失败的回调放到数组里      if(this.status&#x3D;&#x3D;&#x3D;PROMISE_STATUS_PENDING)&#123;          this.onFulfilledFns.push(()&#x3D;&gt;&#123;            try&#123;              const value &#x3D;onFulfilled(this.value)              resolve(value)            &#125;catch(err)&#123;              reject(err)            &#125;            &#125;)          this.onRejectedFns.push(()&#x3D;&gt;&#123;          try&#123;              const reason &#x3D;onRejected(this.value)              resolve(reason)            &#125;catch(err)&#123;              reject(err)            &#125;            &#125;)      &#125;    &#125;)  &#125;&#125;const promise &#x3D;new DiyPromise((resolve,reject)&#x3D;&gt;&#123;reject()  resolve()&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>因为try，catch重复代码太多可以进行封装抽取</strong></p><h3 id="改良版2-0"><a href="#改良版2-0" class="headerlink" title="改良版2.0"></a>改良版2.0</h3><p>1.封装try和catch<br>2.实现对象方法和类方法</p><pre class="line-numbers language-none"><code class="language-none">const PROMISE_STATUS_PENDING&#x3D;&#39;pending&#39;const PROMISE_STATUS_FULFILLED&#x3D;&#39;fulfilled&#39;const PROMISE_STATUS_REJECTED&#x3D;&#39;rejected&#39;&#x2F;&#x2F;工具函数function execFunctionWithCatchErr(execFn,value,resolve,reject)&#123;  try&#123;    const result &#x3D;execFn(value)    resolve(result)  &#125;catch(err)&#123;    reject(err)  &#125; &#125;class DiyPromise&#123;constructor(executor)&#123;    this.status&#x3D;PROMISE_STATUS_PENDING  &#x2F;&#x2F;promise的状态    this.value&#x3D;undefined &#x2F;&#x2F;保存reject和resolve里面的参数    this.reason&#x3D;undefined    this.onFulfilledFns&#x3D;[] &#x2F;&#x2F;把回调的方法放数组里然后遍历去执行    this.onRejectedFns&#x3D;[]        const resolve&#x3D;(value)&#x3D;&gt;&#123;      if(this.status &#x3D;&#x3D;&#x3D; PROMISE_STATUS_PENDING)&#123;        &#x2F;&#x2F;添加微任务        queueMicrotask(()&#x3D;&gt;&#123;          &#x2F;&#x2F;如果状态不等于pending就不执行          if(this.status!&#x3D;&#x3D;PROMISE_STATUS_PENDING) return           this.status&#x3D;PROMISE_STATUS_FULFILLED          this.value&#x3D;value          console.log(&#39;resolve调用&#39;)          this.onFulfilledFns.forEach(fn&#x3D;&gt;&#123;          fn(this.value)          &#125;)        &#125;)      &#125;    &#125;    const reject&#x3D;(reason)&#x3D;&gt;&#123;    if(this.status &#x3D;&#x3D;&#x3D; PROMISE_STATUS_PENDING)&#123;        &#x2F;&#x2F;添加微任务        queueMicrotask(()&#x3D;&gt;&#123;          &#x2F;&#x2F;如果状态不等于pending就不执行          if(this.status!&#x3D;&#x3D;PROMISE_STATUS_PENDING) return         this.status&#x3D;PROMISE_STATUS_REJECTED          this.reason&#x3D;reason          console.log(&#39;reject调用&#39;)          this.onRejectedFns.forEach(fn&#x3D;&gt;&#123;          fn(this.reason)          &#125;)        &#125;)      &#125;    &#125;    try&#123;      executor(resolve,reject)    &#125;catch(err)&#123;      reject(err)    &#125;      &#125;  then(onFulfilled,onRejected)&#123;    &#x2F;&#x2F;catch封装，当then里没有第二个参数的时候，由catch接收err    onRejected&#x3D;onRejected|| (err&#x3D;&gt;&#123;throw err&#125;)    &#x2F;&#x2F;当执行finally中间有rejected的时候，catch用的是then方法接受的第一个参数不是undefined，要把value给return出去    onFulfilled&#x3D;onRejected|| (value&#x3D;&gt;&#123;return value&#125;)        return new DiyPromise((resolve,reject)&#x3D;&gt;&#123;    &#x2F;&#x2F;1.如果then调用的时候，状态已经确定下来,比如在定时器里调用promise。then方法      if(this.status&#x3D;&#x3D;&#x3D;PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled)&#123;        execFunctionWithCatchErr(onFulfilled,this.value,resolve,reject)      &#125;      if(this.status&#x3D;&#x3D;&#x3D;PROMISE_STATUS_REJECTED &amp;&amp; onRejected)&#123;        execFunctionWithCatchErr(onFulfilled,this.reason,resolve,reject)          &#125;      &#x2F;&#x2F;2.当状态是pending的时候      &#x2F;&#x2F;在传入的时候进行参数的判断，未空的时候进行处理，将成功的回调和失败的回调放到数组里      if(this.status&#x3D;&#x3D;&#x3D;PROMISE_STATUS_PENDING)&#123;        if(onFulfilled)&#123;          this.onFulfilledFns.push(()&#x3D;&gt;&#123;            execFunctionWithCatchErr(onFulfilled,this.value,resolve,reject)          &#125;)        &#125;   if(onRejected)&#123;        this.onRejectedFns.push(()&#x3D;&gt;&#123;          execFunctionWithCatchErr(onFulfilled,this.reason,resolve,reject)           &#125;)        &#125;       &#125;    &#125;)  &#125;  &#x2F;&#x2F;catch方法的封装  catch(onRejected)&#123;  return this.then(undefined,onRejected)  &#125;  &#x2F;&#x2F;finally方法的封装  finally(onFinally)&#123;  this.then(()&#x3D;&gt;&#123;      onFinally()    &#125;,()&#x3D;&gt;&#123;    onFinally()    &#125;)  &#125;    &#x2F;&#x2F;resolve和reject方法  static resolve(value)&#123;  return new DiyPromise((resolve)&#x3D;&gt;resolve(value))  &#125;  static reject(reason)&#123;  return new DiyPromise((resolve,reject)&#x3D;&gt;reject(reason))  &#125;    &#x2F;&#x2F;all方法  static all(promises)&#123;    &#x2F;&#x2F;什么时候执行resolve和reject  return new DiyPromise((resolve,reject)&#x3D;&gt;&#123;    const values&#x3D;[]      promises.forEach(promise&#x3D;&gt;&#123;      promise.then(res&#x3D;&gt;&#123;        values.push(res)          if(values.length&#x3D;&#x3D;&#x3D;promises.length)&#123;          resolve(values)          &#125;        &#125;,err&#x3D;&gt;&#123;        reject(err)        &#125;)      &#125;)    &#125;)  &#125;  &#x2F;&#x2F;allSettled  static allSettled(promises)&#123;  return new DiyPromise((resolve)&#x3D;&gt;&#123;    const results&#x3D;[]      promises.forEach(promise&#x3D;&gt;&#123;      promise.then(res&#x3D;&gt;&#123;        results.push(&#123;status:PROMISE_STATUS_FULFILLED,value:res&#125;)          if(results.length&#x3D;&#x3D;&#x3D;promises.length)&#123;          resolve(results)          &#125;        &#125;,err&#x3D;&gt;&#123;        results.push(&#123;status:PROMISE_STATUS_REJECTED,value:err&#125;)          if(results.length&#x3D;&#x3D;&#x3D;promises.length)&#123;          resolve(results)          &#125;        &#125;)      &#125;)    &#125;)  &#125;    &#x2F;&#x2F;race  static race(promises)&#123;  return new DiyPromise((resolve,reject)&#x3D;&gt;&#123;            &#x2F;&#x2F;笨办法      promises.forEach(promise&#x3D;&gt;&#123;      promise.then(res&#x3D;&gt;&#123;          resolve(res)        &#125;,err&#x3D;&gt;&#123;        reject(err)        &#125;)      &#125;)       &#x2F;&#x2F;回调它本身      promises.forEach(promise&#x3D;&gt;&#123;      promise.then(resolve,reject)      &#125;)    &#125;)  &#125;    &#x2F;&#x2F;any  static any()&#123;    const reasons&#x3D;[]  return new DiyPromise((resolve,reject)&#x3D;&gt;&#123;      promises.forEach(promise&#x3D;&gt;&#123;      promise.then(resolve,err&#x3D;&gt;&#123;      reasons.push(err)        if(reasons.length&#x3D;&#x3D;&#x3D;promises.length)&#123;        reject(new AggregateError(reasons))        &#125;      &#125;)       &#125;)    &#125;)   &#125;   &#125;const promise &#x3D;new DiyPromise((resolve,reject)&#x3D;&gt;&#123;reject(111)  &#x2F;&#x2F;resolve(222)&#125;)promise.then(res&#x3D;&gt;&#123;console.log(&#39;res1&#39;,res)  return &#39;aaa&#39;&#125;,(err)&#x3D;&gt;&#123;console.log(&#39;err1&#39;,err)  return &#39;bbb&#39;&#125;).then(res&#x3D;&gt;&#123;console.log(&#39;res2&#39;,res)&#125;,(err)&#x3D;&gt;&#123;console.log(&#39;err1&#39;,err)  return &#39;bbb&#39;&#125;)promise.then(res&#x3D;&gt;&#123;console.log(res)&#125;).catch(err&#x3D;&gt;&#123;console.log(err)&#125;).finally(()&#x3D;&gt;&#123;console.log(&#39;finally&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="promise手写总结">promise手写总结</h2><br><p>1.promise的规范：promiseA+ <a href="https://promisesaplus.com/">promisea+规范官网</a>。<br>2.promise类的设计：class 的方式也可以使用function的方式<br>3.构造函数的规划：</p><pre class="line-numbers language-none"><code class="language-none">constructor()&#123;    &#x2F;&#x2F;定义状态    &#x2F;&#x2F;定义resolve，reject回调    &#x2F;&#x2F;resolve执行微任务队列，改变状态，获取value，then传入执行回调    &#x2F;&#x2F;reject执行微任务队列，改变状态，获取reason，then传入执行回调    &#x2F;&#x2F;try catch    executor(resolve,reject)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.then方法的实现</p><pre class="line-numbers language-none"><code class="language-none">then(onFulfilled,onRejected)&#123;    &#x2F;&#x2F;this.onFulfilled&#x3D;onFulfilled    &#x2F;&#x2F;this.onRejected&#x3D;onRejected  ——最简单的实现    &#x2F;&#x2F;1.判断穿进的参数是否有值，给地默认值    &#x2F;&#x2F;2.返回promise resolve &#x2F;reject    &#x2F;&#x2F;3.判断之前的promise的状态是否确定 确定的话直接执行    &#x2F;&#x2F;4.添加到数组中push(（）&#x3D;&gt;执行 onFulfilled&#x2F;onRejected 直接执行代码)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.catch方法</p><pre class="line-numbers language-none"><code class="language-none">catch(onRejected)&#123;    return this.then(undefined,onRejected)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>6.finally方法</p><pre class="line-numbers language-none"><code class="language-none">finally(onFinally)&#123;    return this.then(()&#x3D;&gt;&#123;        onFinally()        &#125;,()&#x3D;&gt;&#123;        onFinally()    &#125;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7.reject/resolve<br>8.all/allSettled<br><strong>重点：要知搭配resolve和reject什么时候执行</strong><br>all：<br>1.所有的都有结果<br>2.有一个reject<br><strong>allSettled：所有都有结果，并且一定执行resolve</strong><br>9.race/any<br>race：只要有结果，就返回<br>any：<br>1.必须等到一个resolve结果<br>2.都没有resolve，所有的都是reject</p>]]></content>
      
      
      <categories>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识this并手写call，apply和bind</title>
      <link href="/2022/02/10/this/"/>
      <url>/2022/02/10/this/</url>
      
        <content type="html"><![CDATA[<h2 class="bamboo-h " id="认识this">认识this</h2><br><div class="note info"><p>在全局作用域中，不同的环境的this有不同的指向。</p></div><pre><code>浏览器——&gt;window;node——&gt;&#123;&#125;</code></pre><p><strong>ps</strong>:在node环境中，每个js脚本都被当成一个module,module——&gt;加载——&gt;编译——&gt;找到一个函数——&gt;执行这个函数.call({})</p><ul><li>this是执行上下文中的一条记录。</li><li>this是动态绑定的，在函数执行的时候才绑定。</li><li>this指向跟函数所处的位置没有关系，跟函数被调用的方式有关。</li></ul><h2 class="bamboo-h " id="this的绑定规则">this的绑定规则</h2><br><p><strong>1.默认绑定？函数独立调用的时候！</strong></p><span class="pbg yellow">指向全局作用域</span><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;案例一function foo1()&#123;    console.log(this);&#125;function foo2()&#123;    console.log(this)    foo1()&#125;function foo3()&#123;    console.log(this)    foo2()&#125;foo3()&#x2F;&#x2F;三个window对象&#x2F;&#x2F;案例二var obj &#x3D; &#123;  name: &quot;hhx&quot;,  foo: function () &#123;    console.log(this);  &#125;,&#125;;var bar &#x3D; obj.foo;bar();&#x2F;&#x2F;window对象&#x2F;&#x2F;案例三function foo()&#123;console.log(this)&#125;var obj &#x3D; &#123;  name: &quot;hhx&quot;,  foo: foo&#125;;var bar &#x3D; obj.foo;bar();&#x2F;&#x2F;window对象&#x2F;&#x2F;案例五function foo()&#123;function bar()&#123;  console.log(this)  &#125;  return bar&#125;var fn&#x3D;foo()fn() &#x2F;&#x2F;window对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.隐式绑定？通过对象调用！</strong></p><div class="note warning"><p>必须在调用的对象内部有一个对函数的引用，没有引用的话，在调用的时候，会报找不到该函数的错误。</p></div><p>eg：obj.fn()  </p><pre class="line-numbers language-none"><code class="language-none">var obj&#x3D;&#123;foo:function()&#123;  console.log(this.name)  &#125;&#125;var obj2&#x3D;&#123;name:&#39;obj2&#39;,  bar:obj.foo&#125;obj2.bar()&#x2F;&#x2F;打印的是name:obj2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.显式绑定？call apply bind</strong></p><span class="pbg yellow">foo直接调用和call/apply调用的不同在于this的绑定不同foo</span>,<span class="pbg yellow">直接调用指向的是全局对象</span><pre class="line-numbers language-none"><code class="language-none">function foo()&#123;console.log(&#39;函数被调用了&#39;,this.name)&#125;var obj&#x3D;&#123;name:&#39;hhx&#39;&#125;foo.call(obj)foo.apply(obj)&#x2F;&#x2F;hhx&#x2F;&#x2F;call和apply在执行函数的时候可以指定this的绑定对象，显式绑定&#x2F;&#x2F;call、apply的区别&#x2F;&#x2F;call传参的时候用逗号隔开&#x2F;&#x2F;apply通过数组来传参数function foo()&#123;console.log(this)&#125;&#x2F;&#x2F;foo.call(&#39;a&#39;)var newFoo&#x3D;foo.bind(&#39;a&#39;)newFoo()  &#x2F;&#x2F;通过bind绑定this到字符串a上，会产生一个新的函数需要调用一下。&#x2F;&#x2F;默认绑定和显示绑定冲突的时候，显示绑定的优先级更高。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4.new绑定？使用new关键字！</strong><br>1.创建一个新对象<br>2.新对象执行prototype连接<br>3.把新对象绑定到函数调用的this上<br>4.如果函数没有返回其他对象，表达式会返回这个新对象</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;通过new关键字构造一个函数，这个时候this是在调用构造器时创造出来的对象function Person(name,age)&#123;this.name&#x3D;name  this.age&#x3D;age&#125;var p1&#x3D;new Person(&#39;hhx&#39;,18)console.log(p1.name,p1.age)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="this和内置函数的关系">this和内置函数的关系</h2><br><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;案例一setTimeout(function()&#123;console.log(this)&#125;,2000)&#x2F;&#x2F;这里面的this指向window&#x2F;&#x2F;案例二 监听点击事件box.onclick&#x3D;function()&#123;console.log(this)&#125;&#x2F;&#x2F;相当于 box.onclick()&#x2F;&#x2F;打印结果是box这个元素box.addEventListener(&#39;click&#39;,function()&#123;console.log(this)&#125;)&#x2F;&#x2F;相当于显示绑定 call 打印结果是box这个元素&#x2F;&#x2F;案例三var team&#x3D;[&#39;abc&#39;,&#39;dem&#39;]team.forEach(function()&#123;console.log(this)&#125;,&#39;123&#39;)&#x2F;&#x2F;结果 ‘123’ ‘123’&#x2F;&#x2F;有些函数内部会有参数可以让你去绑定相对应的this&#x2F;&#x2F;如果默认不写绑定的就是全局window对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="this绑定规则的优先级">this绑定规则的优先级</h2><br><p>1.独立调用优先级最低。<br>2.显示绑定的优先级高于隐式绑定，包括apply，call，bind。<br>3.new绑定优先级高于隐式绑定。<br>4.new的优先级高于显示绑定，new关键字不能和apply，call一起使用。</p><span class="pbg yellow">例子</span><pre class="line-numbers language-none"><code class="language-none">function foo()&#123;console.log(this)&#125;var bar&#x3D;foo.bind(&#39;aaa&#39;)var obj&#x3D;new bar()console.log(obj)&#x2F;&#x2F;打印结果是foo()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="note warning"><p>有些语法超过我们的规则之外</p></div><p><strong>1.忽略显示绑定</strong></p><pre class="line-numbers language-none"><code class="language-none">function foo()&#123;console.log(this)&#125;foo.apply(null)foo.apply(undefined)&#x2F;&#x2F;如果显示绑定绑定的是null，undefined的时候，会自动将this绑定成全局对象。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.间接函数引用</strong></p><pre class="line-numbers language-none"><code class="language-none">var obj1&#x3D;&#123;foo:function()&#123;  console.log(this)  &#125;&#125;var obj2 &#x3D; &#123;  name:&#39;obj2&#39;&#125;;(obj2.bar&#x3D;obj1.foo)()&#x2F;&#x2F;在这里认为是独立函数的运用&#x3D;&#x3D;foo()&#x2F;&#x2F;指向window<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span class="pbg yellow">ps如果一行没有加分号</span>,<span class="pbg yellow">意味着代码还没有结束</span>,<span class="pbg yellow">会跟下面的代码连起来一起执行</span>。<pre class="line-numbers language-none"><code class="language-none">function foo(el)&#123;console.log(el,this.id)&#125;var obj&#x3D;&#123;id:&#39;hhx&#39;&#125;[1,2,3].forEach(foo,obj)&#x2F;&#x2F;会直接报错&#x2F;&#x2F;需要添加括号或者把123数组赋值给一个新数组 var nums&#x3D;[1，2，3]&#x2F;&#x2F;结果是1 hhx 2 hhx 3 hhx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.箭头函数</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;3.1 箭头函数不能绑定<span class="pbg yellow">this</span>，<span class="pbg yellow">arguments</span>，<span class="pbg yellow">不能使用构造函数（new）</span>。<br>&nbsp;&nbsp;&nbsp;&nbsp;3.2 简写规则：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个箭头函数，只有一行代码，并且返回一个对象？怎么简写<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var bar=() =&gt;  ({ name:’hhx’, age : ‘13’})  利用小括号～<br>&nbsp;&nbsp;&nbsp;&nbsp;3.3 箭头函数的this，根据外层作用域来查找this。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;定义对象的时候并没有定义作用域,定义函数的时候会有作用域var name&#x3D;&#39;hhx&#39;var obj&#x3D;&#123;  name:&#39;123&#39;foo:()&#x3D;&gt; console.log(this.name)foo1:function()&#123;  return function()&#123;    console.log(this.name)    &#125;  &#125;foo2:function()&#123;  return ()&#x3D;&gt;&#123;    console.log(this.name)    &#125;  &#125;&#125;var obj2&#x3D;&#123;name:&#39;456&#39;&#125;obj.foo() &#x2F;&#x2F; hhx 打印的是windowobj.foo1()() &#x2F;&#x2F;hhx 打印的是window 把它放做独立函数调用，因为相当于里面的函数单独调用执行obj.foo2()() &#x2F;&#x2F;123 箭头函数不绑定this，上级作用域的this是objobj.foo2.call(obj2)() &#x2F;&#x2F;456 上层作用域绑定了一个obj2obj.foo2().call(obj2) &#x2F;&#x2F;123 上层作用域找到obj&#x2F;&#x2F;this 1:52:25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 class="bamboo-h " id="手写绑定this函数">手写绑定this函数</h2><br><h3 class="bamboo-h " id="实现call">实现call</h3><br><p><strong>实现call思路</strong><br>1.首先要获取到需要被执行的函数<br>2.对thisArg转换成对象类型 ，防止传入的是非对象类型，null和undefined的话默认为window<br>3.对额外参数进行接收并处理<br>4.调用需要被执行的函数<br>5.将最终的结果返回出去</p><pre class="line-numbers language-none"><code class="language-none">Function.prototype.selfCall&#x3D;function(thisArg,...args)&#123;    &#x2F;&#x2F;首先要获取到需要被执行的函数    &#x2F;&#x2F;通过this来获取函数    var fn&#x3D;this &#x2F;&#x2F;this指向被调用的函数    &#x2F;&#x2F;调用被执行函数    &#x2F;&#x2F;fn()    thisArg &#x3D; thisArg ? Object(thisArg) : window    thisArg.fn&#x3D;fn    var result&#x3D;thisArg.fn(...args)    &#x2F;&#x2F;如果直接执行是默认调用 会把this绑定到window上，所以可以通过中间值把函数绑定到thisArg上    &#x2F;&#x2F;会导致对象上多出一个fn属性    delete thisArg.fn    &#x2F;&#x2F;上面的...args是对参数的简写，表示除第一个参数外其他的所有参数    &#x2F;&#x2F;下面的...args是值扩展运算符，就不用一一传入参数内容    return result&#125;function foo()&#123;console.log(&#39;执行了foo函数&#39;,this)&#125;&#x2F;&#x2F;默认进行了隐式绑定foo.selfCall()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="实现apply">实现apply</h3><br><p><strong>实现思路和call一样</strong></p><pre class="line-numbers language-none"><code class="language-none">Function.prototype.selfApply&#x3D;function(thisArg,args)&#123;&#x2F;&#x2F;因为apply传入的是数组，只有一个参数，所以不需要。。。    &#x2F;&#x2F;在call用的是...args,默认没有参数，该args为空[]    var fn&#x3D;this    thisArg &#x3D;        thisArg !&#x3D;&#x3D; null &amp;&amp; thisArg !&#x3D;&#x3D; undefined ? Object(thisArg) : window;    &#x2F;&#x2F;进行优化，如果传入的是0    thisArg.fn&#x3D;fn    &#x2F;&#x2F;需要对传进来的参数进行判断    args&#x3D;args||[]    var result&#x3D;thisArg.fn(args)    delete thisArg.fn    return result&#125;function foo()&#123;console.log(&#39;执行了foo函数&#39;,this)&#125;foo.selfApply()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 class="bamboo-h " id="实现bind">实现bind</h3><br><pre class="line-numbers language-none"><code class="language-none">Function.prototype.selfBind&#x3D;function(thisArg,...args)&#123;&#x2F;&#x2F;1.获取到真实需要调用的函数    var fn&#x3D;this    &#x2F;&#x2F;2.绑定this    thisArg &#x3D;        thisArg !&#x3D;&#x3D; null &amp;&amp; thisArg !&#x3D;&#x3D; undefined ? Object(thisArg) : window;    return function(...arg1)&#123;        &#x2F;&#x2F;3.将函数放到thisArg中调用        thisArg.fn&#x3D;fn        &#x2F;&#x2F;4.对两个传入的参数进行合并        var finalArgs&#x3D;[...args,...arg1]        var result&#x3D;thisArg.fn(...finalArgs)        delete thisArg.fn        &#x2F;&#x2F;5.返回结果        return result  &#125;&#125;function foo()&#123;console.log(&#39;执行了foo函数&#39;,this)&#125;var bar&#x3D;foo.selfBind()bar()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> this相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp&amp;udp</title>
      <link href="/2022/02/10/tcp-udp/"/>
      <url>/2022/02/10/tcp-udp/</url>
      
        <content type="html"><![CDATA[<div class="note info"><p>在了解tcp和udp之前，可以先对计算机网络做一些简单的了解。</p></div><h2 class="bamboo-h " id="网络模型">网络模型</h2><br><p><strong>五层模型</strong>：</p><ul><li>物理层</li><li>数据链路层</li><li>网络层  (主机之间通信)</li><li>传输层  (应用程序间通信)</li><li>应用层 </li></ul><p><strong>七层模型</strong>：</p><ul><li>物理层</li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>会话层，表示层，应用层</li></ul><p><strong>传输过程中文件会被拆分成多个数据包来传输</strong></p><wavy>补充：</wavy><ul><li>mac地址：也称物理地址(硬件地址)，由网络设备制造商生产时写在硬件内部，无论接到哪个网络，都拥有相同的mac地址。</li><li>IP：IP数据报送到目的主机(主机之间的逻辑通信)，计算机的地址就是ip地址 访问网站就是你的计算机向另外一台计算机请求信息,但是IP只负责传送到对方电脑，不知道哪个程序，所以在发送前会加上主机的ip地址。</li><li>UDP：用户数据包协议 （通过端口号UDP把指定数据包发送给程序）（应用程序之间通信）</li></ul><span class="pbg yellow">udp</span>对于<span class="pbg yellow">错误的数据包</span>：udp不重发，直接丢弃当前的包，并且udp发送之后不知道能不能到达目的地。<br><span class="pbg yellow">udp的问题</span>：1.数据包容易丢失。2.大文件拆分成小数据包传输的时候不知道如何组装这些数据包，把他们还原成完整的文件。<br><p>而<span class="pbg yellow">tcp</span>解决了udp的问题 ：如果数据包丢失的话就重传。tcp引入了<span class="pbg yellow">数据包排序机制</span>，把打乱的数据包组合成完整的文件。所以tcp头包含了<strong>目标端口</strong>和<strong>本机端口</strong>，还提供了<strong>排序的序列号</strong>。(TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度)。所以tcp是一种<span class="pbg yellow">面向连接</span>，<span class="pbg yellow">可靠的</span>，<span class="pbg yellow">基于字节流</span>的传输层通信协议。</p><h2 class="bamboo-h " id="浏览器和服务器交互过程">浏览器和服务器交互过程</h2><br><p><img src="/2022/02/10/tcp-udp/1.png" class="lazyload placeholder" data-srcset="/2022/02/10/tcp-udp/1.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="服务器和客户端传输过程"><br><strong>首先，建立连接阶段。</strong>这个阶段是通过“<span class="pbg yellow">三次握手</span>”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送<span class="pbg yellow">三个数据包</span>以确认连接的建立。<br><strong>其次，传输数据阶段。</strong>在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，<span class="pbg yellow">在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制</span>。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。<br><strong>最后，断开连接阶段。</strong>数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。</p><h2 class="bamboo-h " id="TCP和UDP的不同">TCP和UDP的不同</h2><br><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>可靠的</td><td>不可靠的</td></tr><tr><td>面向连接的</td><td>无连接的</td></tr><tr><td>传输效率低</td><td>传输效率高</td></tr><tr><td>对系统资源要求高</td><td>对系统资源要求低</td></tr><tr><td>少量数据</td><td>大量数据</td></tr><tr><td>每次连接只有两个端点</td><td>支持一对一，一对多，多对多</td></tr><tr><td>拥塞控制，网络拥塞会导致效率变低</td><td>没有拥塞控制</td></tr><tr><td>面向字节流，根据对方的窗口之和网络拥塞程度来决定报文段包含多少字节，如果数据块太长，可以划分短一点在传送</td><td>面向报文，一次性交付一个完整报文。</td></tr><tr><td>提供双全工通信，在发送和接受都设置缓存，临时存放数据</td><td></td></tr></tbody></table><h2 class="bamboo-h " id="三次握手">三次握手</h2><br><p><img src="/2022/02/10/tcp-udp/2.png" class="lazyload placeholder" data-srcset="/2022/02/10/tcp-udp/2.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="三次握手"><br><strong>第一次握手</strong><br>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 <span class="pbg yellow">SYN-SENT</span> 状态。<br><strong>第二次握手</strong><br>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入<span class="pbg yellow">SYN-RECEIVED</span>  状态。<br><strong>第三次握手</strong><br>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入了<span class="pbg yellow">ESTABLISHED</span>  状态，服务端收到这个应答后也进入 <span class="pbg yellow">ESTABLISHED</span> 状态，此时连接建立成功。</p><wavy>只有两次怎么办？</wavy><p>如果只有 2 次的话，服务器并不清楚浏览器是否收到他发过去的信息，可能会一直发送消息。</p><h2 class="bamboo-h " id="四次挥手">四次挥手</h2><br><p><img src="/2022/02/10/tcp-udp/3.png" class="lazyload placeholder" data-srcset="/2022/02/10/tcp-udp/3.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="四次挥手"><br><strong>第一次挥手</strong><br>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。<br><strong>第二次挥手</strong><br>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 <span class="pbg yellow">CLOSE_WAIT</span> 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。<br><strong>第三次挥手</strong><br>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入<span class="pbg yellow">LAST-ACK</span>  状态。<br><strong>PS</strong>：通过延迟确认的技术(通常有时间限制，否则对方会误认为需要重传)，可以将第二次和第三次握手合并，延迟 ACK 包的发送。<br><strong>第四次挥手</strong><br>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 <span class="pbg yellow">TIME-WAIT</span> 状态。该状态会持续 2MSL(最长报文段寿命，指报文段在网络中生存的时间，超时会被抛弃) 时间，若该时间段内没有 B 的重发请求的话，就进入 <span class="pbg yellow">CLOSED</span> 状态。当 B 收到确认应答后，也便进入 <span class="pbg yellow">CLOSED</span> 状态。</p><h2 id="http和TCP的关系"><a href="#http和TCP的关系" class="headerlink" title="http和TCP的关系"></a>http和TCP的关系</h2><p>TCP 协议对应于传输层，而 HTTP 协议对应于应用层，从本质上来说，二者没有可比性：</p><ul><li>HTTP 对应于应用层，TCP 协议对应于传输层</li><li>HTTP 是无状态的短连接，而 TCP 是有状态的长连接</li><li>HTTP 协议是在 TCP 协议之上建立的，HTTP 在发起请求时通过 TCP 协议建立起连接服务器的通道，请求结束后，立即断开 TCP 连接</li><li>TCP是传输层协议，定义的是数据传输和连接方式的规范，HTTP是应用层协议，定义的是传输数据的内容的规范。<br><img src="/2022/02/10/tcp-udp/4.png" class="lazyload placeholder" data-srcset="/2022/02/10/tcp-udp/4.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="过程"></li></ul>]]></content>
      
      
      <categories>
          
          <category> tcp&amp;udp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是加密算法？</title>
      <link href="/2022/02/09/jiami/"/>
      <url>/2022/02/09/jiami/</url>
      
        <content type="html"><![CDATA[<h2 class="bamboo-h " id="浏览器加密">浏览器加密</h2><br><div class="note info"><p>浏览器的安全一直以来是人们关注的问题，为了让网上的信息不被泄漏，做出了很多努力，其中主要包括对称加密，非对称加密，以及两种加密结合的方式。</p></div><h2 class="bamboo-h " id="对称加密">对称加密</h2><br><p><img src="/2022/02/09/jiami/1.jpg" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/1.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="对称加密"></p><emp>思考</emp> ：<p>&nbsp;&nbsp;1.浏览器和服务器双方如何拿到钥匙？<br>&nbsp;&nbsp;2.传输钥匙会不会被截获，别人也能拿到钥匙？  </p><h2 class="bamboo-h " id="非对称加密">非对称加密</h2><br><p><img src="/2022/02/09/jiami/2.jpg" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/2.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="非对称加密"></p><wavy>好处：</wavy>  第三方就算截获了公钥和加密消息也没用，因为没有私钥，不能获取消息。  <br><emp>思考</emp> ：非对称加密非常耗时，怎么解决？<br><h2 class="bamboo-h " id="对称加密+非对称加密">对称加密+非对称加密</h2><br><p><img src="/2022/02/09/jiami/3.jpg" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/3.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="对称加密+非对称加密"></p><wavy>好处：</wavy>  这样双方都可以得到安全的对称加密的钥匙，虽然公钥是明文传输的但是只要私钥被自己保管，所以可以保证钥匙的安全。这样就可以用钥匙(对称加密)进行消息的加密了。也解决了多次非对称加密的产生的时间损耗问题。  <br><emp>思考</emp> ：如果中间人获取公钥之后，发送了自己的公钥，那他就能破解浏览器用他的公钥加密之后的密钥，他还能把密钥用刚才获取的公钥进行加密发送给服务器，这样双方都不会发觉密钥已经泄漏了。<br><div class="note warning"><p>经过这几步操作，其实还是逃不过一个问题，如何证明你的身份，也就是说怎么证明公钥是你的？</p></div><p class="p center large blue">那就是数字证书！！</p><p><img src="/2022/02/09/jiami/4.jpg" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/4.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="数字证书"><br>    1.CA机构拥有非对称加密的私钥和公钥。 <br>    2.CA机构对证书明文数据T进行hash。 <br>    3.对hash后的值用私钥加密，得到数字签名S。<br>    4.数字签名+明文数据=数字证书<br><img src="/2022/02/09/jiami/5.jpg" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/5.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="浏览器验证"><br>    1.浏览器拿到证书，得到明文T，签名S。<br>    2.用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥）得到S’。<br>    3.用证书里指明的hash算法对明文T进行hash得到T’。<br>    4.显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。<br>    5.所以此时比较S’是否等于T’，等于则表明证书可信。</p><p class="p warning">中间人有可能篡改该证书吗？</p><p>&nbsp;&nbsp;假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</p><p class="p warning">既然不可能篡改，那整个证书被掉包呢？</p><p>&nbsp;&nbsp;假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？<strong>但是</strong>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。<br>&nbsp;&nbsp;<strong>操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。</strong></p><div class="note info"><p>数据被哈希的原因：因为非对称加密比较耗时，但是hash之后得到的是固定长度的信息，这样加解密比较方便。非对称加密可以加密的消息体长度有上限，必须先hash保证定长结果。</p></div><p><img src="/2022/02/09/jiami/image.png" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/image.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="完整流程"><br>&nbsp;&nbsp;ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。 这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中。<br><img src="/2022/02/09/jiami/ca.png" class="lazyload placeholder" data-srcset="/2022/02/09/jiami/ca.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="CA证书"></p>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序章</title>
      <link href="/2022/01/16/hello-world/"/>
      <url>/2022/01/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>静态服务器搭建的博客</p><h2 id="人的进步在于承认自己的不足"><a href="#人的进步在于承认自己的不足" class="headerlink" title="人的进步在于承认自己的不足"></a>人的进步在于承认自己的不足</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>2022-01-16 23:51</p><h3 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h3><p>地球某处</p><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><p>序章</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>以前总觉得学习是一种被推着走的过程，从小学到高中，囫囵吞枣的接受着老师或外界灌输的知识，或死记或硬背，为了高考这一目标而前进，等真正到了大学没有人再推着你的时候，身后的压力突然消失，自己也变得茫然，肚子里的那点墨水根本不是自己想要了解的，抑或是和别人聊天时，才发现自己错过了很多学习的时机，所以想通过这种个人网站的方式来记录，或许人会随着时间消失，但知识不会，也有可能我现在所记录的也是以后别人学习的材料……总而言之，读万卷书，行万里路，各位一起进步吧。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
